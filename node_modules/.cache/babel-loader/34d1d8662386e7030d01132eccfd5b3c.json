{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport const getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\n/**\n * Transform a list of rows into a tree structure where each row references its parent and children.\n * If a row have a parent which does not exist in the input rows, creates an auto generated row\n *\n ```\n params = {\n   ids: [0, 1, 2],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...} },\n   rows: [\n     { id: 0, path: ['A'] },\n     { id: 1, path: ['B', 'A'] },\n     { id: 2, path: ['B', 'A', 'A'] }\n   ],\n   defaultGroupingExpansionDepth: 0,\n }\n Returns:\n {\n   ids: [0, 1, 2, 'auto-generated-row-B'],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...}, 'auto-generated-row-B': {} },\n   tree: {\n     '0': { id: 0, parent: null, childrenExpanded: false, depth: 0, groupingKey: 'A' },\n     'auto-generated-row-B': { id: 'auto-generated-row-B', parent: null, childrenExpanded: false, depth: 0, groupingKey: 'B' },\n     '1': { id: 1, parent: 'auto-generated-row-B', childrenExpanded: false, depth: 1, groupingKey: 'A' },\n     '2': { id: 2, parent: 1, childrenExpanded: false, depth: 2, groupingKey: 'A' },\n   },\n   treeDepth: 3,\n }\n ```\n */\n\nexport const buildRowTree = params => {\n  // During the build, we store the children as a Record to avoid linear complexity when checking if a children is already defined.\n  const tempTree = {};\n  let treeDepth = 1;\n  const ids = [...params.ids];\n\n  const idRowsLookup = _extends({}, params.idRowsLookup);\n\n  const idToIdLookup = _extends({}, params.idToIdLookup);\n\n  const groupingCriteriaToIdTree = {};\n\n  const isGroupExpandedByDefault = node => {\n    var _params$previousTree, _params$previousTree$;\n\n    const previousExpansion = (_params$previousTree = params.previousTree) == null ? void 0 : (_params$previousTree$ = _params$previousTree[node.id]) == null ? void 0 : _params$previousTree$.childrenExpanded;\n\n    if (previousExpansion != null) {\n      return previousExpansion;\n    }\n\n    if (!node.children || !node.children.length) {\n      return undefined;\n    }\n\n    if (params.isGroupExpandedByDefault) {\n      return params.isGroupExpandedByDefault(node);\n    }\n\n    return params.defaultGroupingExpansionDepth === -1 || params.defaultGroupingExpansionDepth > node.depth;\n  };\n\n  for (let i = 0; i < params.rows.length; i += 1) {\n    const row = params.rows[i];\n    let keyToIdSubTree = groupingCriteriaToIdTree;\n    let parentNode = null;\n\n    for (let depth = 0; depth < row.path.length; depth += 1) {\n      const {\n        key,\n        field: rawField\n      } = row.path[depth];\n      const field = rawField != null ? rawField : '__no_field__';\n      let nodeId;\n      let fieldSubTree = keyToIdSubTree[field];\n\n      if (!fieldSubTree) {\n        fieldSubTree = {};\n        keyToIdSubTree[field] = fieldSubTree;\n      }\n\n      let keyConfig = fieldSubTree[key.toString()];\n\n      if (keyConfig) {\n        if (depth === row.path.length - 1) {\n          var _params$onDuplicatePa;\n\n          (_params$onDuplicatePa = params.onDuplicatePath) == null ? void 0 : _params$onDuplicatePa.call(params, keyConfig.id, row.id, row.path);\n        }\n\n        nodeId = keyConfig.id;\n      } else {\n        if (depth === row.path.length - 1) {\n          nodeId = row.id;\n        } else {\n          nodeId = getGroupRowIdFromPath(row.path.slice(0, depth + 1));\n        }\n\n        keyConfig = {\n          id: nodeId,\n          children: {}\n        };\n        fieldSubTree[key.toString()] = keyConfig;\n      }\n\n      keyToIdSubTree = keyConfig.children;\n\n      if (!tempTree[nodeId]) {\n        var _parentNode$id, _parentNode;\n\n        const isAutoGenerated = depth < row.path.length - 1;\n        const node = {\n          id: nodeId,\n          isAutoGenerated,\n          parent: (_parentNode$id = (_parentNode = parentNode) == null ? void 0 : _parentNode.id) != null ? _parentNode$id : null,\n          groupingKey: key,\n          groupingField: rawField,\n          depth\n        };\n\n        if (isAutoGenerated) {\n          idRowsLookup[nodeId] = {};\n          ids.push(nodeId);\n        }\n\n        tempTree[nodeId] = node;\n      }\n\n      if (parentNode != null) {\n        if (!parentNode.children) {\n          parentNode.children = {};\n        }\n\n        parentNode.children[nodeId] = nodeId;\n      }\n\n      parentNode = tempTree[nodeId];\n    }\n\n    treeDepth = Math.max(treeDepth, row.path.length);\n  }\n\n  const tree = {};\n\n  for (let i = 0; i < ids.length; i += 1) {\n    var _params$previousTree2, _previousNode$childre, _node$children, _previousNode$childre2;\n\n    const rowId = ids[i];\n    const tempNode = tempTree[rowId];\n\n    const nodeWithoutChildrenExpansion = _extends({}, tempNode, {\n      children: tempNode.children ? Object.values(tempNode.children) : undefined\n    });\n\n    const node = _extends({}, nodeWithoutChildrenExpansion, {\n      childrenExpanded: isGroupExpandedByDefault(nodeWithoutChildrenExpansion)\n    });\n\n    const previousNode = (_params$previousTree2 = params.previousTree) == null ? void 0 : _params$previousTree2[node.id];\n    const shouldReUsePreviousNode = previousNode && previousNode.isAutoGenerated === node.isAutoGenerated && previousNode.parent === node.parent && previousNode.groupingKey === node.groupingKey && previousNode.groupingField === node.groupingField && previousNode.depth === node.depth && previousNode.childrenExpanded === node.childrenExpanded && ((_previousNode$childre = previousNode.children) == null ? void 0 : _previousNode$childre.length) === ((_node$children = node.children) == null ? void 0 : _node$children.length) && ((_previousNode$childre2 = previousNode.children) == null ? void 0 : _previousNode$childre2.every((childId, index) => {\n      var _node$children2;\n\n      return ((_node$children2 = node.children) == null ? void 0 : _node$children2[index]) === childId;\n    }));\n\n    if (shouldReUsePreviousNode) {\n      tree[rowId] = previousNode;\n    } else {\n      tree[rowId] = node;\n    }\n  }\n\n  return {\n    tree,\n    treeDepth,\n    ids,\n    idRowsLookup,\n    idToIdLookup,\n    groupingName: params.groupingName\n  };\n};","map":{"version":3,"names":["_extends","getGroupRowIdFromPath","path","pathStr","map","groupingCriteria","field","key","join","buildRowTree","params","tempTree","treeDepth","ids","idRowsLookup","idToIdLookup","groupingCriteriaToIdTree","isGroupExpandedByDefault","node","_params$previousTree","_params$previousTree$","previousExpansion","previousTree","id","childrenExpanded","children","length","undefined","defaultGroupingExpansionDepth","depth","i","rows","row","keyToIdSubTree","parentNode","rawField","nodeId","fieldSubTree","keyConfig","toString","_params$onDuplicatePa","onDuplicatePath","call","slice","_parentNode$id","_parentNode","isAutoGenerated","parent","groupingKey","groupingField","push","Math","max","tree","_params$previousTree2","_previousNode$childre","_node$children","_previousNode$childre2","rowId","tempNode","nodeWithoutChildrenExpansion","Object","values","previousNode","shouldReUsePreviousNode","every","childId","index","_node$children2","groupingName"],"sources":["/Users/dewan03/project/project/node_modules/@mui/x-data-grid-pro/utils/tree/buildRowTree.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport const getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\n/**\n * Transform a list of rows into a tree structure where each row references its parent and children.\n * If a row have a parent which does not exist in the input rows, creates an auto generated row\n *\n ```\n params = {\n   ids: [0, 1, 2],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...} },\n   rows: [\n     { id: 0, path: ['A'] },\n     { id: 1, path: ['B', 'A'] },\n     { id: 2, path: ['B', 'A', 'A'] }\n   ],\n   defaultGroupingExpansionDepth: 0,\n }\n Returns:\n {\n   ids: [0, 1, 2, 'auto-generated-row-B'],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...}, 'auto-generated-row-B': {} },\n   tree: {\n     '0': { id: 0, parent: null, childrenExpanded: false, depth: 0, groupingKey: 'A' },\n     'auto-generated-row-B': { id: 'auto-generated-row-B', parent: null, childrenExpanded: false, depth: 0, groupingKey: 'B' },\n     '1': { id: 1, parent: 'auto-generated-row-B', childrenExpanded: false, depth: 1, groupingKey: 'A' },\n     '2': { id: 2, parent: 1, childrenExpanded: false, depth: 2, groupingKey: 'A' },\n   },\n   treeDepth: 3,\n }\n ```\n */\n\nexport const buildRowTree = params => {\n  // During the build, we store the children as a Record to avoid linear complexity when checking if a children is already defined.\n  const tempTree = {};\n  let treeDepth = 1;\n  const ids = [...params.ids];\n\n  const idRowsLookup = _extends({}, params.idRowsLookup);\n\n  const idToIdLookup = _extends({}, params.idToIdLookup);\n\n  const groupingCriteriaToIdTree = {};\n\n  const isGroupExpandedByDefault = node => {\n    var _params$previousTree, _params$previousTree$;\n\n    const previousExpansion = (_params$previousTree = params.previousTree) == null ? void 0 : (_params$previousTree$ = _params$previousTree[node.id]) == null ? void 0 : _params$previousTree$.childrenExpanded;\n\n    if (previousExpansion != null) {\n      return previousExpansion;\n    }\n\n    if (!node.children || !node.children.length) {\n      return undefined;\n    }\n\n    if (params.isGroupExpandedByDefault) {\n      return params.isGroupExpandedByDefault(node);\n    }\n\n    return params.defaultGroupingExpansionDepth === -1 || params.defaultGroupingExpansionDepth > node.depth;\n  };\n\n  for (let i = 0; i < params.rows.length; i += 1) {\n    const row = params.rows[i];\n    let keyToIdSubTree = groupingCriteriaToIdTree;\n    let parentNode = null;\n\n    for (let depth = 0; depth < row.path.length; depth += 1) {\n      const {\n        key,\n        field: rawField\n      } = row.path[depth];\n      const field = rawField != null ? rawField : '__no_field__';\n      let nodeId;\n      let fieldSubTree = keyToIdSubTree[field];\n\n      if (!fieldSubTree) {\n        fieldSubTree = {};\n        keyToIdSubTree[field] = fieldSubTree;\n      }\n\n      let keyConfig = fieldSubTree[key.toString()];\n\n      if (keyConfig) {\n        if (depth === row.path.length - 1) {\n          var _params$onDuplicatePa;\n\n          (_params$onDuplicatePa = params.onDuplicatePath) == null ? void 0 : _params$onDuplicatePa.call(params, keyConfig.id, row.id, row.path);\n        }\n\n        nodeId = keyConfig.id;\n      } else {\n        if (depth === row.path.length - 1) {\n          nodeId = row.id;\n        } else {\n          nodeId = getGroupRowIdFromPath(row.path.slice(0, depth + 1));\n        }\n\n        keyConfig = {\n          id: nodeId,\n          children: {}\n        };\n        fieldSubTree[key.toString()] = keyConfig;\n      }\n\n      keyToIdSubTree = keyConfig.children;\n\n      if (!tempTree[nodeId]) {\n        var _parentNode$id, _parentNode;\n\n        const isAutoGenerated = depth < row.path.length - 1;\n        const node = {\n          id: nodeId,\n          isAutoGenerated,\n          parent: (_parentNode$id = (_parentNode = parentNode) == null ? void 0 : _parentNode.id) != null ? _parentNode$id : null,\n          groupingKey: key,\n          groupingField: rawField,\n          depth\n        };\n\n        if (isAutoGenerated) {\n          idRowsLookup[nodeId] = {};\n          ids.push(nodeId);\n        }\n\n        tempTree[nodeId] = node;\n      }\n\n      if (parentNode != null) {\n        if (!parentNode.children) {\n          parentNode.children = {};\n        }\n\n        parentNode.children[nodeId] = nodeId;\n      }\n\n      parentNode = tempTree[nodeId];\n    }\n\n    treeDepth = Math.max(treeDepth, row.path.length);\n  }\n\n  const tree = {};\n\n  for (let i = 0; i < ids.length; i += 1) {\n    var _params$previousTree2, _previousNode$childre, _node$children, _previousNode$childre2;\n\n    const rowId = ids[i];\n    const tempNode = tempTree[rowId];\n\n    const nodeWithoutChildrenExpansion = _extends({}, tempNode, {\n      children: tempNode.children ? Object.values(tempNode.children) : undefined\n    });\n\n    const node = _extends({}, nodeWithoutChildrenExpansion, {\n      childrenExpanded: isGroupExpandedByDefault(nodeWithoutChildrenExpansion)\n    });\n\n    const previousNode = (_params$previousTree2 = params.previousTree) == null ? void 0 : _params$previousTree2[node.id];\n    const shouldReUsePreviousNode = previousNode && previousNode.isAutoGenerated === node.isAutoGenerated && previousNode.parent === node.parent && previousNode.groupingKey === node.groupingKey && previousNode.groupingField === node.groupingField && previousNode.depth === node.depth && previousNode.childrenExpanded === node.childrenExpanded && ((_previousNode$childre = previousNode.children) == null ? void 0 : _previousNode$childre.length) === ((_node$children = node.children) == null ? void 0 : _node$children.length) && ((_previousNode$childre2 = previousNode.children) == null ? void 0 : _previousNode$childre2.every((childId, index) => {\n      var _node$children2;\n\n      return ((_node$children2 = node.children) == null ? void 0 : _node$children2[index]) === childId;\n    }));\n\n    if (shouldReUsePreviousNode) {\n      tree[rowId] = previousNode;\n    } else {\n      tree[rowId] = node;\n    }\n  }\n\n  return {\n    tree,\n    treeDepth,\n    ids,\n    idRowsLookup,\n    idToIdLookup,\n    groupingName: params.groupingName\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}