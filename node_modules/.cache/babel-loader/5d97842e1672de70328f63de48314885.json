{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { passFilterLogic } from '@mui/x-data-grid-pro/internals';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nexport const GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = '__row_group_by_columns_group__';\nexport const ROW_GROUPING_STRATEGY = 'grouping-columns';\nexport const getRowGroupingFieldFromGroupingCriteria = groupingCriteria => {\n  if (groupingCriteria === null) {\n    return GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD;\n  }\n\n  return `__row_group_by_columns_group_${groupingCriteria}__`;\n};\nexport const getRowGroupingCriteriaFromGroupingField = groupingColDefField => {\n  const match = groupingColDefField.match(/^__row_group_by_columns_group_(.*)__$/);\n\n  if (!match) {\n    return null;\n  }\n\n  return match[1];\n};\nexport const isGroupingColumn = field => field === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD || getRowGroupingCriteriaFromGroupingField(field) !== null;\n/**\n * When filtering a group, we only want to filter according to the items related to this grouping column.\n */\n\nconst shouldApplyFilterItemOnGroup = (columnField, node) => {\n  if (columnField === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD) {\n    return true;\n  }\n\n  const groupingCriteriaField = getRowGroupingCriteriaFromGroupingField(columnField);\n  return groupingCriteriaField === node.groupingField;\n};\n/**\n * A leaf is visible if it passed the filter\n * A group is visible if all the following criteria are met:\n * - One of its children is passing the filter\n * - It is passing the filter\n */\n\n\nexport const filterRowTreeFromGroupingColumns = params => {\n  const {\n    rowTree,\n    isRowMatchingFilters,\n    filterModel\n  } = params;\n  const visibleRowsLookup = {};\n  const filteredRowsLookup = {};\n  const filteredDescendantCountLookup = {};\n\n  const filterTreeNode = (node, areAncestorsExpanded, ancestorsResults) => {\n    var _node$children;\n\n    let isPassingFiltering = false;\n    let filterResults = {\n      passingFilterItems: null,\n      passingQuickFilterValues: null\n    };\n\n    if (isRowMatchingFilters && node.position !== 'footer') {\n      const shouldApplyItem = node.isAutoGenerated ? columnField => shouldApplyFilterItemOnGroup(columnField, node) : undefined;\n      filterResults = isRowMatchingFilters(node.id, shouldApplyItem);\n    } else {\n      isPassingFiltering = true;\n    }\n\n    let filteredDescendantCount = 0;\n    (_node$children = node.children) == null ? void 0 : _node$children.forEach(childId => {\n      const childNode = rowTree[childId];\n      const childSubTreeSize = filterTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded, [...ancestorsResults, filterResults]);\n      filteredDescendantCount += childSubTreeSize;\n    });\n\n    if (isPassingFiltering === false) {\n      var _node$children2;\n\n      if ((_node$children2 = node.children) != null && _node$children2.length) {\n        // If node has children - it's passing if at least one child passes filters\n        isPassingFiltering = filteredDescendantCount > 0;\n      } else {\n        const allResults = [...ancestorsResults, filterResults];\n        isPassingFiltering = passFilterLogic(allResults.map(result => result.passingFilterItems), allResults.map(result => result.passingQuickFilterValues), filterModel, params.apiRef);\n      }\n    }\n\n    visibleRowsLookup[node.id] = isPassingFiltering && areAncestorsExpanded;\n    filteredRowsLookup[node.id] = isPassingFiltering;\n\n    if (node.footerId != null) {\n      visibleRowsLookup[node.footerId] = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;\n    }\n\n    if (!isPassingFiltering) {\n      return 0;\n    }\n\n    filteredDescendantCountLookup[node.id] = filteredDescendantCount;\n\n    if (!node.children && !node.isAutoGenerated) {\n      return filteredDescendantCount + 1;\n    }\n\n    return filteredDescendantCount;\n  };\n\n  const nodes = Object.values(rowTree);\n\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n\n    if (node.depth === 0) {\n      filterTreeNode(node, true, []);\n    }\n  }\n\n  return {\n    visibleRowsLookup,\n    filteredRowsLookup,\n    filteredDescendantCountLookup\n  };\n};\nexport const getColDefOverrides = (groupingColDefProp, fields) => {\n  if (typeof groupingColDefProp === 'function') {\n    return groupingColDefProp({\n      groupingName: ROW_GROUPING_STRATEGY,\n      fields\n    });\n  }\n\n  return groupingColDefProp;\n};\nexport const mergeStateWithRowGroupingModel = rowGroupingModel => state => _extends({}, state, {\n  rowGrouping: _extends({}, state.rowGrouping, {\n    model: rowGroupingModel\n  })\n});\nexport const setStrategyAvailability = (apiRef, disableRowGrouping) => {\n  let isAvailable;\n\n  if (disableRowGrouping) {\n    isAvailable = () => false;\n  } else {\n    isAvailable = () => {\n      const rowGroupingSanitizedModel = gridRowGroupingSanitizedModelSelector(apiRef);\n      return rowGroupingSanitizedModel.length > 0;\n    };\n  }\n\n  apiRef.current.unstable_setStrategyAvailability('rowTree', ROW_GROUPING_STRATEGY, isAvailable);\n};\nexport const getGroupingRules = _ref => {\n  let {\n    sanitizedRowGroupingModel,\n    columnsLookup\n  } = _ref;\n  return sanitizedRowGroupingModel.map(field => {\n    var _columnsLookup$field;\n\n    return {\n      field,\n      groupingValueGetter: (_columnsLookup$field = columnsLookup[field]) == null ? void 0 : _columnsLookup$field.groupingValueGetter\n    };\n  });\n};\n/**\n * Compares two sets of grouping rules to determine if they are equal or not.\n */\n\nexport const areGroupingRulesEqual = function () {\n  let previousValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let newValue = arguments.length > 1 ? arguments[1] : undefined;\n\n  if (previousValue.length !== newValue.length) {\n    return false;\n  }\n\n  return newValue.every((newRule, newRuleIndex) => {\n    const previousRule = previousValue[newRuleIndex];\n\n    if (previousRule.groupingValueGetter !== newRule.groupingValueGetter) {\n      return false;\n    }\n\n    if (previousRule.field !== newRule.field) {\n      return false;\n    }\n\n    return true;\n  });\n};","map":{"version":3,"names":["_extends","passFilterLogic","gridRowGroupingSanitizedModelSelector","GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD","ROW_GROUPING_STRATEGY","getRowGroupingFieldFromGroupingCriteria","groupingCriteria","getRowGroupingCriteriaFromGroupingField","groupingColDefField","match","isGroupingColumn","field","shouldApplyFilterItemOnGroup","columnField","node","groupingCriteriaField","groupingField","filterRowTreeFromGroupingColumns","params","rowTree","isRowMatchingFilters","filterModel","visibleRowsLookup","filteredRowsLookup","filteredDescendantCountLookup","filterTreeNode","areAncestorsExpanded","ancestorsResults","_node$children","isPassingFiltering","filterResults","passingFilterItems","passingQuickFilterValues","position","shouldApplyItem","isAutoGenerated","undefined","id","filteredDescendantCount","children","forEach","childId","childNode","childSubTreeSize","childrenExpanded","_node$children2","length","allResults","map","result","apiRef","footerId","nodes","Object","values","i","depth","getColDefOverrides","groupingColDefProp","fields","groupingName","mergeStateWithRowGroupingModel","rowGroupingModel","state","rowGrouping","model","setStrategyAvailability","disableRowGrouping","isAvailable","rowGroupingSanitizedModel","current","unstable_setStrategyAvailability","getGroupingRules","sanitizedRowGroupingModel","columnsLookup","_columnsLookup$field","groupingValueGetter","areGroupingRulesEqual","previousValue","newValue","every","newRule","newRuleIndex","previousRule"],"sources":["/Users/dewan03/project/project/node_modules/@mui/x-data-grid-premium/hooks/features/rowGrouping/gridRowGroupingUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { passFilterLogic } from '@mui/x-data-grid-pro/internals';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nexport const GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = '__row_group_by_columns_group__';\nexport const ROW_GROUPING_STRATEGY = 'grouping-columns';\nexport const getRowGroupingFieldFromGroupingCriteria = groupingCriteria => {\n  if (groupingCriteria === null) {\n    return GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD;\n  }\n\n  return `__row_group_by_columns_group_${groupingCriteria}__`;\n};\nexport const getRowGroupingCriteriaFromGroupingField = groupingColDefField => {\n  const match = groupingColDefField.match(/^__row_group_by_columns_group_(.*)__$/);\n\n  if (!match) {\n    return null;\n  }\n\n  return match[1];\n};\nexport const isGroupingColumn = field => field === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD || getRowGroupingCriteriaFromGroupingField(field) !== null;\n\n/**\n * When filtering a group, we only want to filter according to the items related to this grouping column.\n */\nconst shouldApplyFilterItemOnGroup = (columnField, node) => {\n  if (columnField === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD) {\n    return true;\n  }\n\n  const groupingCriteriaField = getRowGroupingCriteriaFromGroupingField(columnField);\n  return groupingCriteriaField === node.groupingField;\n};\n/**\n * A leaf is visible if it passed the filter\n * A group is visible if all the following criteria are met:\n * - One of its children is passing the filter\n * - It is passing the filter\n */\n\n\nexport const filterRowTreeFromGroupingColumns = params => {\n  const {\n    rowTree,\n    isRowMatchingFilters,\n    filterModel\n  } = params;\n  const visibleRowsLookup = {};\n  const filteredRowsLookup = {};\n  const filteredDescendantCountLookup = {};\n\n  const filterTreeNode = (node, areAncestorsExpanded, ancestorsResults) => {\n    var _node$children;\n\n    let isPassingFiltering = false;\n    let filterResults = {\n      passingFilterItems: null,\n      passingQuickFilterValues: null\n    };\n\n    if (isRowMatchingFilters && node.position !== 'footer') {\n      const shouldApplyItem = node.isAutoGenerated ? columnField => shouldApplyFilterItemOnGroup(columnField, node) : undefined;\n      filterResults = isRowMatchingFilters(node.id, shouldApplyItem);\n    } else {\n      isPassingFiltering = true;\n    }\n\n    let filteredDescendantCount = 0;\n    (_node$children = node.children) == null ? void 0 : _node$children.forEach(childId => {\n      const childNode = rowTree[childId];\n      const childSubTreeSize = filterTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded, [...ancestorsResults, filterResults]);\n      filteredDescendantCount += childSubTreeSize;\n    });\n\n    if (isPassingFiltering === false) {\n      var _node$children2;\n\n      if ((_node$children2 = node.children) != null && _node$children2.length) {\n        // If node has children - it's passing if at least one child passes filters\n        isPassingFiltering = filteredDescendantCount > 0;\n      } else {\n        const allResults = [...ancestorsResults, filterResults];\n        isPassingFiltering = passFilterLogic(allResults.map(result => result.passingFilterItems), allResults.map(result => result.passingQuickFilterValues), filterModel, params.apiRef);\n      }\n    }\n\n    visibleRowsLookup[node.id] = isPassingFiltering && areAncestorsExpanded;\n    filteredRowsLookup[node.id] = isPassingFiltering;\n\n    if (node.footerId != null) {\n      visibleRowsLookup[node.footerId] = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;\n    }\n\n    if (!isPassingFiltering) {\n      return 0;\n    }\n\n    filteredDescendantCountLookup[node.id] = filteredDescendantCount;\n\n    if (!node.children && !node.isAutoGenerated) {\n      return filteredDescendantCount + 1;\n    }\n\n    return filteredDescendantCount;\n  };\n\n  const nodes = Object.values(rowTree);\n\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n\n    if (node.depth === 0) {\n      filterTreeNode(node, true, []);\n    }\n  }\n\n  return {\n    visibleRowsLookup,\n    filteredRowsLookup,\n    filteredDescendantCountLookup\n  };\n};\nexport const getColDefOverrides = (groupingColDefProp, fields) => {\n  if (typeof groupingColDefProp === 'function') {\n    return groupingColDefProp({\n      groupingName: ROW_GROUPING_STRATEGY,\n      fields\n    });\n  }\n\n  return groupingColDefProp;\n};\nexport const mergeStateWithRowGroupingModel = rowGroupingModel => state => _extends({}, state, {\n  rowGrouping: _extends({}, state.rowGrouping, {\n    model: rowGroupingModel\n  })\n});\nexport const setStrategyAvailability = (apiRef, disableRowGrouping) => {\n  let isAvailable;\n\n  if (disableRowGrouping) {\n    isAvailable = () => false;\n  } else {\n    isAvailable = () => {\n      const rowGroupingSanitizedModel = gridRowGroupingSanitizedModelSelector(apiRef);\n      return rowGroupingSanitizedModel.length > 0;\n    };\n  }\n\n  apiRef.current.unstable_setStrategyAvailability('rowTree', ROW_GROUPING_STRATEGY, isAvailable);\n};\nexport const getGroupingRules = ({\n  sanitizedRowGroupingModel,\n  columnsLookup\n}) => sanitizedRowGroupingModel.map(field => {\n  var _columnsLookup$field;\n\n  return {\n    field,\n    groupingValueGetter: (_columnsLookup$field = columnsLookup[field]) == null ? void 0 : _columnsLookup$field.groupingValueGetter\n  };\n});\n/**\n * Compares two sets of grouping rules to determine if they are equal or not.\n */\n\nexport const areGroupingRulesEqual = (previousValue = [], newValue) => {\n  if (previousValue.length !== newValue.length) {\n    return false;\n  }\n\n  return newValue.every((newRule, newRuleIndex) => {\n    const previousRule = previousValue[newRuleIndex];\n\n    if (previousRule.groupingValueGetter !== newRule.groupingValueGetter) {\n      return false;\n    }\n\n    if (previousRule.field !== newRule.field) {\n      return false;\n    }\n\n    return true;\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}