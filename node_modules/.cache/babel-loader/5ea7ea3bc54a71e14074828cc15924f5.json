{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { gridAggregationLookupSelector } from './gridAggregationSelectors';\nimport { GridFooterCell } from '../../../components/GridFooterCell';\nimport { GridAggregationHeader } from '../../../components/GridAggregationHeader';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst AGGREGATION_WRAPPABLE_PROPERTIES = ['valueGetter', 'valueFormatter', 'renderCell', 'renderHeader', 'filterOperators'];\n\nconst getAggregationValueWrappedValueGetter = _ref => {\n  let {\n    value: valueGetter,\n    getCellAggregationResult\n  } = _ref;\n\n  const wrappedValueGetter = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n    if (cellAggregationResult != null) {\n      var _cellAggregationResul;\n\n      return (_cellAggregationResul = cellAggregationResult == null ? void 0 : cellAggregationResult.value) != null ? _cellAggregationResul : null;\n    }\n\n    if (valueGetter) {\n      return valueGetter(params);\n    }\n\n    return params.row[params.field];\n  };\n\n  return wrappedValueGetter;\n};\n\nconst getAggregationValueWrappedValueFormatter = _ref2 => {\n  let {\n    value: valueFormatter,\n    aggregationRule,\n    getCellAggregationResult\n  } = _ref2;\n\n  // If neither the inline aggregation function nor the footer aggregation function have a custom value formatter,\n  // Then we don't wrap the column value formatter\n  if (!aggregationRule.aggregationFunction.valueFormatter) {\n    return valueFormatter;\n  }\n\n  const wrappedValueFormatter = params => {\n    if (params.id != null) {\n      const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n      if (cellAggregationResult != null) {\n        return aggregationRule.aggregationFunction.valueFormatter(params);\n      }\n    }\n\n    if (valueFormatter) {\n      return valueFormatter(params);\n    }\n\n    return params.value;\n  };\n\n  return wrappedValueFormatter;\n};\n\nconst getAggregationValueWrappedRenderCell = _ref3 => {\n  let {\n    value: renderCell,\n    aggregationRule,\n    getCellAggregationResult\n  } = _ref3;\n\n  const wrappedRenderCell = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n    if (cellAggregationResult != null) {\n      var _aggregationFunction$;\n\n      if (!renderCell) {\n        if (cellAggregationResult.position === 'footer') {\n          return /*#__PURE__*/_jsx(GridFooterCell, _extends({}, params));\n        }\n\n        return params.formattedValue;\n      }\n\n      const aggregationMeta = {\n        hasCellUnit: (_aggregationFunction$ = aggregationRule.aggregationFunction.hasCellUnit) != null ? _aggregationFunction$ : true,\n        aggregationFunctionName: aggregationRule.aggregationFunctionName\n      };\n      return renderCell(_extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n\n    if (!renderCell) {\n      return params.formattedValue;\n    }\n\n    return renderCell(params);\n  };\n\n  return wrappedRenderCell;\n};\n/**\n * Skips the filtering for aggregated rows\n */\n\n\nconst getWrappedFilterOperators = _ref4 => {\n  let {\n    value: filterOperators,\n    getCellAggregationResult\n  } = _ref4;\n  return filterOperators.map(operator => {\n    return _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          if (getCellAggregationResult(params.id, params.field) != null) {\n            return true;\n          }\n\n          return originalFn(params);\n        };\n      }\n    });\n  });\n};\n/**\n * Add the aggregation method around the header name\n */\n\n\nconst getWrappedRenderHeader = _ref5 => {\n  let {\n    value: renderHeader,\n    aggregationRule\n  } = _ref5;\n\n  const wrappedRenderCell = params => {\n    const aggregationMeta = {\n      aggregationRule\n    };\n\n    if (!renderHeader) {\n      return /*#__PURE__*/_jsx(GridAggregationHeader, _extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n\n    return renderHeader(_extends({}, params, {\n      aggregation: aggregationMeta\n    }));\n  };\n\n  return wrappedRenderCell;\n};\n/**\n * Add a wrapper around each wrappable property of the column to customize the behavior of the aggregation cells.\n */\n\n\nexport const wrapColumnWithAggregationValue = _ref6 => {\n  let {\n    column,\n    apiRef,\n    aggregationRule\n  } = _ref6;\n\n  const getCellAggregationResult = (id, field) => {\n    var _rowNode$children, _rowNode$parent, _gridAggregationLooku;\n\n    let cellAggregationPosition = null;\n    const rowNode = apiRef.current.getRowNode(id);\n\n    if ((_rowNode$children = rowNode.children) != null && _rowNode$children.length) {\n      cellAggregationPosition = 'inline';\n    } else if (id.toString().startsWith('auto-generated-group-footer-')) {\n      cellAggregationPosition = 'footer';\n    }\n\n    if (cellAggregationPosition == null) {\n      return null;\n    } // TODO: Add custom root id\n\n\n    const groupId = cellAggregationPosition === 'inline' ? id : (_rowNode$parent = rowNode.parent) != null ? _rowNode$parent : '';\n    const aggregationResult = (_gridAggregationLooku = gridAggregationLookupSelector(apiRef)[groupId]) == null ? void 0 : _gridAggregationLooku[field];\n\n    if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {\n      return null;\n    }\n\n    return aggregationResult;\n  };\n\n  const aggregationWrappedProperties = {};\n\n  const wrappedColumn = _extends({}, column, {\n    aggregationWrappedProperties\n  });\n\n  const wrapColumnProperty = (property, wrapper) => {\n    const originalValue = column[property];\n    const wrappedProperty = wrapper({\n      apiRef,\n      value: originalValue,\n      colDef: column,\n      aggregationRule,\n      getCellAggregationResult\n    });\n\n    if (wrappedProperty !== originalValue) {\n      aggregationWrappedProperties[property] = {\n        original: originalValue,\n        wrapped: wrappedProperty\n      };\n      wrappedColumn[property] = wrappedProperty;\n    }\n  };\n\n  wrapColumnProperty('valueGetter', getAggregationValueWrappedValueGetter);\n  wrapColumnProperty('valueFormatter', getAggregationValueWrappedValueFormatter);\n  wrapColumnProperty('renderCell', getAggregationValueWrappedRenderCell);\n  wrapColumnProperty('renderHeader', getWrappedRenderHeader);\n  wrapColumnProperty('filterOperators', getWrappedFilterOperators);\n\n  if (Object.keys(aggregationWrappedProperties).length === 0) {\n    return column;\n  }\n\n  return wrappedColumn;\n};\n/**\n * Remove the aggregation wrappers around the wrappable properties of the column.\n */\n\nexport const unwrapColumnFromAggregation = _ref7 => {\n  let {\n    column\n  } = _ref7;\n\n  if (!column.aggregationWrappedProperties) {\n    return column;\n  }\n\n  const originalProperties = Object.entries(column.aggregationWrappedProperties);\n\n  if (originalProperties.length === 0) {\n    return column;\n  }\n\n  const unwrappedColumn = _extends({}, column);\n\n  originalProperties.forEach(_ref8 => {\n    let [propertyName, {\n      original,\n      wrapped\n    }] = _ref8;\n\n    // The value changed since we wrapped it\n    if (wrapped !== column[propertyName]) {\n      return;\n    }\n\n    unwrappedColumn[propertyName] = original;\n  });\n  return unwrappedColumn;\n};","map":{"version":3,"names":["_extends","React","gridAggregationLookupSelector","GridFooterCell","GridAggregationHeader","jsx","_jsx","AGGREGATION_WRAPPABLE_PROPERTIES","getAggregationValueWrappedValueGetter","value","valueGetter","getCellAggregationResult","wrappedValueGetter","params","cellAggregationResult","id","field","_cellAggregationResul","row","getAggregationValueWrappedValueFormatter","valueFormatter","aggregationRule","aggregationFunction","wrappedValueFormatter","getAggregationValueWrappedRenderCell","renderCell","wrappedRenderCell","_aggregationFunction$","position","formattedValue","aggregationMeta","hasCellUnit","aggregationFunctionName","aggregation","getWrappedFilterOperators","filterOperators","map","operator","getApplyFilterFn","filterItem","column","originalFn","getWrappedRenderHeader","renderHeader","wrapColumnWithAggregationValue","apiRef","_rowNode$children","_rowNode$parent","_gridAggregationLooku","cellAggregationPosition","rowNode","current","getRowNode","children","length","toString","startsWith","groupId","parent","aggregationResult","aggregationWrappedProperties","wrappedColumn","wrapColumnProperty","property","wrapper","originalValue","wrappedProperty","colDef","original","wrapped","Object","keys","unwrapColumnFromAggregation","originalProperties","entries","unwrappedColumn","forEach","propertyName"],"sources":["/Users/dewan03/project/project/node_modules/@mui/x-data-grid-premium/hooks/features/aggregation/wrapColumnWithAggregation.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { gridAggregationLookupSelector } from './gridAggregationSelectors';\nimport { GridFooterCell } from '../../../components/GridFooterCell';\nimport { GridAggregationHeader } from '../../../components/GridAggregationHeader';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst AGGREGATION_WRAPPABLE_PROPERTIES = ['valueGetter', 'valueFormatter', 'renderCell', 'renderHeader', 'filterOperators'];\n\nconst getAggregationValueWrappedValueGetter = ({\n  value: valueGetter,\n  getCellAggregationResult\n}) => {\n  const wrappedValueGetter = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n    if (cellAggregationResult != null) {\n      var _cellAggregationResul;\n\n      return (_cellAggregationResul = cellAggregationResult == null ? void 0 : cellAggregationResult.value) != null ? _cellAggregationResul : null;\n    }\n\n    if (valueGetter) {\n      return valueGetter(params);\n    }\n\n    return params.row[params.field];\n  };\n\n  return wrappedValueGetter;\n};\n\nconst getAggregationValueWrappedValueFormatter = ({\n  value: valueFormatter,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  // If neither the inline aggregation function nor the footer aggregation function have a custom value formatter,\n  // Then we don't wrap the column value formatter\n  if (!aggregationRule.aggregationFunction.valueFormatter) {\n    return valueFormatter;\n  }\n\n  const wrappedValueFormatter = params => {\n    if (params.id != null) {\n      const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n      if (cellAggregationResult != null) {\n        return aggregationRule.aggregationFunction.valueFormatter(params);\n      }\n    }\n\n    if (valueFormatter) {\n      return valueFormatter(params);\n    }\n\n    return params.value;\n  };\n\n  return wrappedValueFormatter;\n};\n\nconst getAggregationValueWrappedRenderCell = ({\n  value: renderCell,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  const wrappedRenderCell = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n    if (cellAggregationResult != null) {\n      var _aggregationFunction$;\n\n      if (!renderCell) {\n        if (cellAggregationResult.position === 'footer') {\n          return /*#__PURE__*/_jsx(GridFooterCell, _extends({}, params));\n        }\n\n        return params.formattedValue;\n      }\n\n      const aggregationMeta = {\n        hasCellUnit: (_aggregationFunction$ = aggregationRule.aggregationFunction.hasCellUnit) != null ? _aggregationFunction$ : true,\n        aggregationFunctionName: aggregationRule.aggregationFunctionName\n      };\n      return renderCell(_extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n\n    if (!renderCell) {\n      return params.formattedValue;\n    }\n\n    return renderCell(params);\n  };\n\n  return wrappedRenderCell;\n};\n/**\n * Skips the filtering for aggregated rows\n */\n\n\nconst getWrappedFilterOperators = ({\n  value: filterOperators,\n  getCellAggregationResult\n}) => filterOperators.map(operator => {\n  return _extends({}, operator, {\n    getApplyFilterFn: (filterItem, column) => {\n      const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n      if (!originalFn) {\n        return null;\n      }\n\n      return params => {\n        if (getCellAggregationResult(params.id, params.field) != null) {\n          return true;\n        }\n\n        return originalFn(params);\n      };\n    }\n  });\n});\n/**\n * Add the aggregation method around the header name\n */\n\n\nconst getWrappedRenderHeader = ({\n  value: renderHeader,\n  aggregationRule\n}) => {\n  const wrappedRenderCell = params => {\n    const aggregationMeta = {\n      aggregationRule\n    };\n\n    if (!renderHeader) {\n      return /*#__PURE__*/_jsx(GridAggregationHeader, _extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n\n    return renderHeader(_extends({}, params, {\n      aggregation: aggregationMeta\n    }));\n  };\n\n  return wrappedRenderCell;\n};\n/**\n * Add a wrapper around each wrappable property of the column to customize the behavior of the aggregation cells.\n */\n\n\nexport const wrapColumnWithAggregationValue = ({\n  column,\n  apiRef,\n  aggregationRule\n}) => {\n  const getCellAggregationResult = (id, field) => {\n    var _rowNode$children, _rowNode$parent, _gridAggregationLooku;\n\n    let cellAggregationPosition = null;\n    const rowNode = apiRef.current.getRowNode(id);\n\n    if ((_rowNode$children = rowNode.children) != null && _rowNode$children.length) {\n      cellAggregationPosition = 'inline';\n    } else if (id.toString().startsWith('auto-generated-group-footer-')) {\n      cellAggregationPosition = 'footer';\n    }\n\n    if (cellAggregationPosition == null) {\n      return null;\n    } // TODO: Add custom root id\n\n\n    const groupId = cellAggregationPosition === 'inline' ? id : (_rowNode$parent = rowNode.parent) != null ? _rowNode$parent : '';\n    const aggregationResult = (_gridAggregationLooku = gridAggregationLookupSelector(apiRef)[groupId]) == null ? void 0 : _gridAggregationLooku[field];\n\n    if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {\n      return null;\n    }\n\n    return aggregationResult;\n  };\n\n  const aggregationWrappedProperties = {};\n\n  const wrappedColumn = _extends({}, column, {\n    aggregationWrappedProperties\n  });\n\n  const wrapColumnProperty = (property, wrapper) => {\n    const originalValue = column[property];\n    const wrappedProperty = wrapper({\n      apiRef,\n      value: originalValue,\n      colDef: column,\n      aggregationRule,\n      getCellAggregationResult\n    });\n\n    if (wrappedProperty !== originalValue) {\n      aggregationWrappedProperties[property] = {\n        original: originalValue,\n        wrapped: wrappedProperty\n      };\n      wrappedColumn[property] = wrappedProperty;\n    }\n  };\n\n  wrapColumnProperty('valueGetter', getAggregationValueWrappedValueGetter);\n  wrapColumnProperty('valueFormatter', getAggregationValueWrappedValueFormatter);\n  wrapColumnProperty('renderCell', getAggregationValueWrappedRenderCell);\n  wrapColumnProperty('renderHeader', getWrappedRenderHeader);\n  wrapColumnProperty('filterOperators', getWrappedFilterOperators);\n\n  if (Object.keys(aggregationWrappedProperties).length === 0) {\n    return column;\n  }\n\n  return wrappedColumn;\n};\n/**\n * Remove the aggregation wrappers around the wrappable properties of the column.\n */\n\nexport const unwrapColumnFromAggregation = ({\n  column\n}) => {\n  if (!column.aggregationWrappedProperties) {\n    return column;\n  }\n\n  const originalProperties = Object.entries(column.aggregationWrappedProperties);\n\n  if (originalProperties.length === 0) {\n    return column;\n  }\n\n  const unwrappedColumn = _extends({}, column);\n\n  originalProperties.forEach(([propertyName, {\n    original,\n    wrapped\n  }]) => {\n    // The value changed since we wrapped it\n    if (wrapped !== column[propertyName]) {\n      return;\n    }\n\n    unwrappedColumn[propertyName] = original;\n  });\n  return unwrappedColumn;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}