{"ast":null,"code":"import { gridColumnLookupSelector, gridFilteredRowsLookupSelector, gridRowIdsSelector, gridRowTreeSelector } from '@mui/x-data-grid-pro';\nimport { getAggregationRules } from './gridAggregationUtils';\nimport { gridAggregationModelSelector } from './gridAggregationSelectors';\n\nconst getAggregationCellValue = _ref => {\n  let {\n    apiRef,\n    groupId,\n    field,\n    aggregationFunction,\n    aggregationRowsScope\n  } = _ref;\n  const rowTree = gridRowTreeSelector(apiRef);\n  const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n  let rowIds; // TODO: Add custom root id\n\n  if (groupId === '') {\n    rowIds = gridRowIdsSelector(apiRef).filter(rowId => !rowTree[rowId].isAutoGenerated);\n  } else {\n    rowIds = apiRef.current.getRowGroupChildren({\n      groupId\n    });\n  }\n\n  const values = [];\n  rowIds.forEach(rowId => {\n    var _rowNode$children;\n\n    if (aggregationRowsScope === 'filtered' && filteredRowsLookup[rowId] === false) {\n      return;\n    } // If the row is a group, we want to aggregate based on its children\n    // For instance in the following tree, we want the aggregated values of A to be based on A.A, A.B.A and A.B.B but not A.B\n    // A\n    //   A.A\n    //   A.B\n    //     A.B.A\n    //     A.B.B\n\n\n    const rowNode = apiRef.current.getRowNode(rowId);\n\n    if ((_rowNode$children = rowNode.children) != null && _rowNode$children.length) {\n      return;\n    }\n\n    values.push(apiRef.current.getCellValue(rowId, field));\n  });\n  return aggregationFunction.apply({\n    values\n  });\n};\n\nconst getGroupAggregatedValue = _ref2 => {\n  let {\n    groupId,\n    apiRef,\n    aggregationRowsScope,\n    aggregatedFields,\n    aggregationRules,\n    position\n  } = _ref2;\n  const groupAggregationLookup = {};\n\n  for (let j = 0; j < aggregatedFields.length; j += 1) {\n    const aggregatedField = aggregatedFields[j];\n    const columnAggregationRules = aggregationRules[aggregatedField];\n    groupAggregationLookup[aggregatedField] = {\n      position,\n      value: getAggregationCellValue({\n        apiRef,\n        groupId,\n        field: aggregatedField,\n        aggregationFunction: columnAggregationRules.aggregationFunction,\n        aggregationRowsScope\n      })\n    };\n  }\n\n  return groupAggregationLookup;\n};\n\nexport const createAggregationLookup = _ref3 => {\n  let {\n    apiRef,\n    aggregationFunctions,\n    aggregationRowsScope,\n    getAggregationPosition\n  } = _ref3;\n  const aggregationRules = getAggregationRules({\n    columnsLookup: gridColumnLookupSelector(apiRef),\n    aggregationModel: gridAggregationModelSelector(apiRef),\n    aggregationFunctions\n  });\n  const aggregatedFields = Object.keys(aggregationRules);\n\n  if (aggregatedFields.length === 0) {\n    return {};\n  }\n\n  const aggregationLookup = {};\n  const rowIds = gridRowIdsSelector(apiRef);\n  const rowTree = gridRowTreeSelector(apiRef);\n\n  for (let i = 0; i < rowIds.length; i += 1) {\n    var _node$children;\n\n    const rowId = rowIds[i];\n    const node = rowTree[rowId];\n    const hasChildren = (_node$children = node.children) == null ? void 0 : _node$children.some(childId => {\n      var _rowTree$childId$posi;\n\n      return ((_rowTree$childId$posi = rowTree[childId].position) != null ? _rowTree$childId$posi : 'body') === 'body';\n    });\n\n    if (hasChildren) {\n      const position = getAggregationPosition(node);\n\n      if (position != null) {\n        aggregationLookup[rowId] = getGroupAggregatedValue({\n          groupId: rowId,\n          apiRef,\n          aggregatedFields,\n          aggregationRowsScope,\n          aggregationRules,\n          position\n        });\n      }\n    }\n  } // TODO: Add custom root id\n\n\n  const position = getAggregationPosition(null);\n\n  if (position != null) {\n    aggregationLookup[''] = getGroupAggregatedValue({\n      groupId: '',\n      apiRef,\n      aggregatedFields,\n      aggregationRowsScope,\n      aggregationRules,\n      position\n    });\n  }\n\n  return aggregationLookup;\n};","map":{"version":3,"names":["gridColumnLookupSelector","gridFilteredRowsLookupSelector","gridRowIdsSelector","gridRowTreeSelector","getAggregationRules","gridAggregationModelSelector","getAggregationCellValue","apiRef","groupId","field","aggregationFunction","aggregationRowsScope","rowTree","filteredRowsLookup","rowIds","filter","rowId","isAutoGenerated","current","getRowGroupChildren","values","forEach","_rowNode$children","rowNode","getRowNode","children","length","push","getCellValue","apply","getGroupAggregatedValue","aggregatedFields","aggregationRules","position","groupAggregationLookup","j","aggregatedField","columnAggregationRules","value","createAggregationLookup","aggregationFunctions","getAggregationPosition","columnsLookup","aggregationModel","Object","keys","aggregationLookup","i","_node$children","node","hasChildren","some","childId","_rowTree$childId$posi"],"sources":["/Users/dewan03/project/project/node_modules/@mui/x-data-grid-premium/hooks/features/aggregation/createAggregationLookup.js"],"sourcesContent":["import { gridColumnLookupSelector, gridFilteredRowsLookupSelector, gridRowIdsSelector, gridRowTreeSelector } from '@mui/x-data-grid-pro';\nimport { getAggregationRules } from './gridAggregationUtils';\nimport { gridAggregationModelSelector } from './gridAggregationSelectors';\n\nconst getAggregationCellValue = ({\n  apiRef,\n  groupId,\n  field,\n  aggregationFunction,\n  aggregationRowsScope\n}) => {\n  const rowTree = gridRowTreeSelector(apiRef);\n  const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n  let rowIds; // TODO: Add custom root id\n\n  if (groupId === '') {\n    rowIds = gridRowIdsSelector(apiRef).filter(rowId => !rowTree[rowId].isAutoGenerated);\n  } else {\n    rowIds = apiRef.current.getRowGroupChildren({\n      groupId\n    });\n  }\n\n  const values = [];\n  rowIds.forEach(rowId => {\n    var _rowNode$children;\n\n    if (aggregationRowsScope === 'filtered' && filteredRowsLookup[rowId] === false) {\n      return;\n    } // If the row is a group, we want to aggregate based on its children\n    // For instance in the following tree, we want the aggregated values of A to be based on A.A, A.B.A and A.B.B but not A.B\n    // A\n    //   A.A\n    //   A.B\n    //     A.B.A\n    //     A.B.B\n\n\n    const rowNode = apiRef.current.getRowNode(rowId);\n\n    if ((_rowNode$children = rowNode.children) != null && _rowNode$children.length) {\n      return;\n    }\n\n    values.push(apiRef.current.getCellValue(rowId, field));\n  });\n  return aggregationFunction.apply({\n    values\n  });\n};\n\nconst getGroupAggregatedValue = ({\n  groupId,\n  apiRef,\n  aggregationRowsScope,\n  aggregatedFields,\n  aggregationRules,\n  position\n}) => {\n  const groupAggregationLookup = {};\n\n  for (let j = 0; j < aggregatedFields.length; j += 1) {\n    const aggregatedField = aggregatedFields[j];\n    const columnAggregationRules = aggregationRules[aggregatedField];\n    groupAggregationLookup[aggregatedField] = {\n      position,\n      value: getAggregationCellValue({\n        apiRef,\n        groupId,\n        field: aggregatedField,\n        aggregationFunction: columnAggregationRules.aggregationFunction,\n        aggregationRowsScope\n      })\n    };\n  }\n\n  return groupAggregationLookup;\n};\n\nexport const createAggregationLookup = ({\n  apiRef,\n  aggregationFunctions,\n  aggregationRowsScope,\n  getAggregationPosition\n}) => {\n  const aggregationRules = getAggregationRules({\n    columnsLookup: gridColumnLookupSelector(apiRef),\n    aggregationModel: gridAggregationModelSelector(apiRef),\n    aggregationFunctions\n  });\n  const aggregatedFields = Object.keys(aggregationRules);\n\n  if (aggregatedFields.length === 0) {\n    return {};\n  }\n\n  const aggregationLookup = {};\n  const rowIds = gridRowIdsSelector(apiRef);\n  const rowTree = gridRowTreeSelector(apiRef);\n\n  for (let i = 0; i < rowIds.length; i += 1) {\n    var _node$children;\n\n    const rowId = rowIds[i];\n    const node = rowTree[rowId];\n    const hasChildren = (_node$children = node.children) == null ? void 0 : _node$children.some(childId => {\n      var _rowTree$childId$posi;\n\n      return ((_rowTree$childId$posi = rowTree[childId].position) != null ? _rowTree$childId$posi : 'body') === 'body';\n    });\n\n    if (hasChildren) {\n      const position = getAggregationPosition(node);\n\n      if (position != null) {\n        aggregationLookup[rowId] = getGroupAggregatedValue({\n          groupId: rowId,\n          apiRef,\n          aggregatedFields,\n          aggregationRowsScope,\n          aggregationRules,\n          position\n        });\n      }\n    }\n  } // TODO: Add custom root id\n\n\n  const position = getAggregationPosition(null);\n\n  if (position != null) {\n    aggregationLookup[''] = getGroupAggregatedValue({\n      groupId: '',\n      apiRef,\n      aggregatedFields,\n      aggregationRowsScope,\n      aggregationRules,\n      position\n    });\n  }\n\n  return aggregationLookup;\n};"],"mappings":"AAAA,SAASA,wBAAT,EAAmCC,8BAAnC,EAAmEC,kBAAnE,EAAuFC,mBAAvF,QAAkH,sBAAlH;AACA,SAASC,mBAAT,QAAoC,wBAApC;AACA,SAASC,4BAAT,QAA6C,4BAA7C;;AAEA,MAAMC,uBAAuB,GAAG,QAM1B;EAAA,IAN2B;IAC/BC,MAD+B;IAE/BC,OAF+B;IAG/BC,KAH+B;IAI/BC,mBAJ+B;IAK/BC;EAL+B,CAM3B;EACJ,MAAMC,OAAO,GAAGT,mBAAmB,CAACI,MAAD,CAAnC;EACA,MAAMM,kBAAkB,GAAGZ,8BAA8B,CAACM,MAAD,CAAzD;EACA,IAAIO,MAAJ,CAHI,CAGQ;;EAEZ,IAAIN,OAAO,KAAK,EAAhB,EAAoB;IAClBM,MAAM,GAAGZ,kBAAkB,CAACK,MAAD,CAAlB,CAA2BQ,MAA3B,CAAkCC,KAAK,IAAI,CAACJ,OAAO,CAACI,KAAD,CAAP,CAAeC,eAA3D,CAAT;EACD,CAFD,MAEO;IACLH,MAAM,GAAGP,MAAM,CAACW,OAAP,CAAeC,mBAAf,CAAmC;MAC1CX;IAD0C,CAAnC,CAAT;EAGD;;EAED,MAAMY,MAAM,GAAG,EAAf;EACAN,MAAM,CAACO,OAAP,CAAeL,KAAK,IAAI;IACtB,IAAIM,iBAAJ;;IAEA,IAAIX,oBAAoB,KAAK,UAAzB,IAAuCE,kBAAkB,CAACG,KAAD,CAAlB,KAA8B,KAAzE,EAAgF;MAC9E;IACD,CALqB,CAKpB;IACF;IACA;IACA;IACA;IACA;IACA;;;IAGA,MAAMO,OAAO,GAAGhB,MAAM,CAACW,OAAP,CAAeM,UAAf,CAA0BR,KAA1B,CAAhB;;IAEA,IAAI,CAACM,iBAAiB,GAAGC,OAAO,CAACE,QAA7B,KAA0C,IAA1C,IAAkDH,iBAAiB,CAACI,MAAxE,EAAgF;MAC9E;IACD;;IAEDN,MAAM,CAACO,IAAP,CAAYpB,MAAM,CAACW,OAAP,CAAeU,YAAf,CAA4BZ,KAA5B,EAAmCP,KAAnC,CAAZ;EACD,CArBD;EAsBA,OAAOC,mBAAmB,CAACmB,KAApB,CAA0B;IAC/BT;EAD+B,CAA1B,CAAP;AAGD,CA7CD;;AA+CA,MAAMU,uBAAuB,GAAG,SAO1B;EAAA,IAP2B;IAC/BtB,OAD+B;IAE/BD,MAF+B;IAG/BI,oBAH+B;IAI/BoB,gBAJ+B;IAK/BC,gBAL+B;IAM/BC;EAN+B,CAO3B;EACJ,MAAMC,sBAAsB,GAAG,EAA/B;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,gBAAgB,CAACL,MAArC,EAA6CS,CAAC,IAAI,CAAlD,EAAqD;IACnD,MAAMC,eAAe,GAAGL,gBAAgB,CAACI,CAAD,CAAxC;IACA,MAAME,sBAAsB,GAAGL,gBAAgB,CAACI,eAAD,CAA/C;IACAF,sBAAsB,CAACE,eAAD,CAAtB,GAA0C;MACxCH,QADwC;MAExCK,KAAK,EAAEhC,uBAAuB,CAAC;QAC7BC,MAD6B;QAE7BC,OAF6B;QAG7BC,KAAK,EAAE2B,eAHsB;QAI7B1B,mBAAmB,EAAE2B,sBAAsB,CAAC3B,mBAJf;QAK7BC;MAL6B,CAAD;IAFU,CAA1C;EAUD;;EAED,OAAOuB,sBAAP;AACD,CA1BD;;AA4BA,OAAO,MAAMK,uBAAuB,GAAG,SAKjC;EAAA,IALkC;IACtChC,MADsC;IAEtCiC,oBAFsC;IAGtC7B,oBAHsC;IAItC8B;EAJsC,CAKlC;EACJ,MAAMT,gBAAgB,GAAG5B,mBAAmB,CAAC;IAC3CsC,aAAa,EAAE1C,wBAAwB,CAACO,MAAD,CADI;IAE3CoC,gBAAgB,EAAEtC,4BAA4B,CAACE,MAAD,CAFH;IAG3CiC;EAH2C,CAAD,CAA5C;EAKA,MAAMT,gBAAgB,GAAGa,MAAM,CAACC,IAAP,CAAYb,gBAAZ,CAAzB;;EAEA,IAAID,gBAAgB,CAACL,MAAjB,KAA4B,CAAhC,EAAmC;IACjC,OAAO,EAAP;EACD;;EAED,MAAMoB,iBAAiB,GAAG,EAA1B;EACA,MAAMhC,MAAM,GAAGZ,kBAAkB,CAACK,MAAD,CAAjC;EACA,MAAMK,OAAO,GAAGT,mBAAmB,CAACI,MAAD,CAAnC;;EAEA,KAAK,IAAIwC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,MAAM,CAACY,MAA3B,EAAmCqB,CAAC,IAAI,CAAxC,EAA2C;IACzC,IAAIC,cAAJ;;IAEA,MAAMhC,KAAK,GAAGF,MAAM,CAACiC,CAAD,CAApB;IACA,MAAME,IAAI,GAAGrC,OAAO,CAACI,KAAD,CAApB;IACA,MAAMkC,WAAW,GAAG,CAACF,cAAc,GAAGC,IAAI,CAACxB,QAAvB,KAAoC,IAApC,GAA2C,KAAK,CAAhD,GAAoDuB,cAAc,CAACG,IAAf,CAAoBC,OAAO,IAAI;MACrG,IAAIC,qBAAJ;;MAEA,OAAO,CAAC,CAACA,qBAAqB,GAAGzC,OAAO,CAACwC,OAAD,CAAP,CAAiBnB,QAA1C,KAAuD,IAAvD,GAA8DoB,qBAA9D,GAAsF,MAAvF,MAAmG,MAA1G;IACD,CAJuE,CAAxE;;IAMA,IAAIH,WAAJ,EAAiB;MACf,MAAMjB,QAAQ,GAAGQ,sBAAsB,CAACQ,IAAD,CAAvC;;MAEA,IAAIhB,QAAQ,IAAI,IAAhB,EAAsB;QACpBa,iBAAiB,CAAC9B,KAAD,CAAjB,GAA2Bc,uBAAuB,CAAC;UACjDtB,OAAO,EAAEQ,KADwC;UAEjDT,MAFiD;UAGjDwB,gBAHiD;UAIjDpB,oBAJiD;UAKjDqB,gBALiD;UAMjDC;QANiD,CAAD,CAAlD;MAQD;IACF;EACF,CAzCG,CAyCF;;;EAGF,MAAMA,QAAQ,GAAGQ,sBAAsB,CAAC,IAAD,CAAvC;;EAEA,IAAIR,QAAQ,IAAI,IAAhB,EAAsB;IACpBa,iBAAiB,CAAC,EAAD,CAAjB,GAAwBhB,uBAAuB,CAAC;MAC9CtB,OAAO,EAAE,EADqC;MAE9CD,MAF8C;MAG9CwB,gBAH8C;MAI9CpB,oBAJ8C;MAK9CqB,gBAL8C;MAM9CC;IAN8C,CAAD,CAA/C;EAQD;;EAED,OAAOa,iBAAP;AACD,CA/DM"},"metadata":{},"sourceType":"module"}