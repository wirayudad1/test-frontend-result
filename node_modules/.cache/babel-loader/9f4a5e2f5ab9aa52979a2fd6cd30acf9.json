{"ast":null,"code":"const perf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;\nconst hasAbortController = typeof AbortController === 'function'; // minimal backwards-compatibility polyfill\n// this doesn't have nearly all the checks and whatnot that\n// actual AbortController/Signal has, but it's enough for\n// our purposes, and if used properly, behaves the same.\n\nconst AC = hasAbortController ? AbortController : class AbortController {\n  constructor() {\n    this.signal = new AS();\n  }\n\n  abort() {\n    this.signal.dispatchEvent('abort');\n  }\n\n};\nconst hasAbortSignal = typeof AbortSignal === 'function'; // Some polyfills put this on the AC class, not global\n\nconst hasACAbortSignal = typeof AC.AbortSignal === 'function';\nconst AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {\n  constructor() {\n    this.aborted = false;\n    this._listeners = [];\n  }\n\n  dispatchEvent(type) {\n    if (type === 'abort') {\n      this.aborted = true;\n      const e = {\n        type,\n        target: this\n      };\n      this.onabort(e);\n\n      this._listeners.forEach(f => f(e), this);\n    }\n  }\n\n  onabort() {}\n\n  addEventListener(ev, fn) {\n    if (ev === 'abort') {\n      this._listeners.push(fn);\n    }\n  }\n\n  removeEventListener(ev, fn) {\n    if (ev === 'abort') {\n      this._listeners = this._listeners.filter(f => f !== fn);\n    }\n  }\n\n};\nconst warned = new Set();\n\nconst deprecatedOption = (opt, instead) => {\n  const code = `LRU_CACHE_OPTION_${opt}`;\n\n  if (shouldWarn(code)) {\n    warn(code, `${opt} option`, `options.${instead}`, LRUCache);\n  }\n};\n\nconst deprecatedMethod = (method, instead) => {\n  const code = `LRU_CACHE_METHOD_${method}`;\n\n  if (shouldWarn(code)) {\n    const {\n      prototype\n    } = LRUCache;\n    const {\n      get\n    } = Object.getOwnPropertyDescriptor(prototype, method);\n    warn(code, `${method} method`, `cache.${instead}()`, get);\n  }\n};\n\nconst deprecatedProperty = (field, instead) => {\n  const code = `LRU_CACHE_PROPERTY_${field}`;\n\n  if (shouldWarn(code)) {\n    const {\n      prototype\n    } = LRUCache;\n    const {\n      get\n    } = Object.getOwnPropertyDescriptor(prototype, field);\n    warn(code, `${field} property`, `cache.${instead}`, get);\n  }\n};\n\nconst emitWarning = function () {\n  typeof process === 'object' && process && typeof process.emitWarning === 'function' ? process.emitWarning(...arguments) : console.error(...arguments);\n};\n\nconst shouldWarn = code => !warned.has(code);\n\nconst warn = (code, what, instead, fn) => {\n  warned.add(code);\n  const msg = `The ${what} is deprecated. Please use ${instead} instead.`;\n  emitWarning(msg, 'DeprecationWarning', code, fn);\n};\n\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* istanbul ignore next - This is a little bit ridiculous, tbh.\n * The maximum array length is 2^32-1 or thereabouts on most JS impls.\n * And well before that point, you're caching the entire world, I mean,\n * that's ~32GB of just integers for the next/prev links, plus whatever\n * else to hold that many keys and values.  Just filling the memory with\n * zeroes at init time is brutal when you get that big.\n * But why not be complete?\n * Maybe in the future, these limits will have expanded. */\n\n\nconst getUintArray = max => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size);\n    this.fill(0);\n  }\n\n}\n\nclass Stack {\n  constructor(max) {\n    if (max === 0) {\n      return [];\n    }\n\n    const UintArray = getUintArray(max);\n    this.heap = new UintArray(max);\n    this.length = 0;\n  }\n\n  push(n) {\n    this.heap[this.length++] = n;\n  }\n\n  pop() {\n    return this.heap[--this.length];\n  }\n\n}\n\nclass LRUCache {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      fetchContext,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet\n    } = options; // deprecated options, don't trigger a warning for getting them if\n    // the thing being passed in is another LRUCache we're copying.\n\n    const {\n      length,\n      maxAge,\n      stale\n    } = options instanceof LRUCache ? {} : options;\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer');\n    }\n\n    const UintArray = max ? getUintArray(max) : Array;\n\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max);\n    }\n\n    this.max = max;\n    this.maxSize = maxSize;\n    this.maxEntrySize = maxEntrySize || this.maxSize;\n    this.sizeCalculation = sizeCalculation || length;\n\n    if (this.sizeCalculation) {\n      if (!this.maxSize && !this.maxEntrySize) {\n        throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n      }\n\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function');\n      }\n    }\n\n    this.fetchMethod = fetchMethod || null;\n\n    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {\n      throw new TypeError('fetchMethod must be a function if specified');\n    }\n\n    this.fetchContext = fetchContext;\n\n    if (!this.fetchMethod && fetchContext !== undefined) {\n      throw new TypeError('cannot set fetchContext without fetchMethod');\n    }\n\n    this.keyMap = new Map();\n    this.keyList = new Array(max).fill(null);\n    this.valList = new Array(max).fill(null);\n    this.next = new UintArray(max);\n    this.prev = new UintArray(max);\n    this.head = 0;\n    this.tail = 0;\n    this.free = new Stack(max);\n    this.initialFill = 1;\n    this.size = 0;\n\n    if (typeof dispose === 'function') {\n      this.dispose = dispose;\n    }\n\n    if (typeof disposeAfter === 'function') {\n      this.disposeAfter = disposeAfter;\n      this.disposed = [];\n    } else {\n      this.disposeAfter = null;\n      this.disposed = null;\n    }\n\n    this.noDisposeOnSet = !!noDisposeOnSet;\n    this.noUpdateTTL = !!noUpdateTTL;\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection; // NB: maxEntrySize is set to maxSize if it's set\n\n    if (this.maxEntrySize !== 0) {\n      if (this.maxSize !== 0) {\n        if (!isPosInt(this.maxSize)) {\n          throw new TypeError('maxSize must be a positive integer if specified');\n        }\n      }\n\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError('maxEntrySize must be a positive integer if specified');\n      }\n\n      this.initializeSizeTracking();\n    }\n\n    this.allowStale = !!allowStale || !!stale;\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n    this.updateAgeOnGet = !!updateAgeOnGet;\n    this.updateAgeOnHas = !!updateAgeOnHas;\n    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n    this.ttlAutopurge = !!ttlAutopurge;\n    this.ttl = ttl || maxAge || 0;\n\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError('ttl must be a positive integer if specified');\n      }\n\n      this.initializeTTLTracking();\n    } // do not allow completely unbounded caches\n\n\n    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {\n      throw new TypeError('At least one of max, maxSize, or ttl is required');\n    }\n\n    if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED';\n\n      if (shouldWarn(code)) {\n        warned.add(code);\n        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n      }\n    }\n\n    if (stale) {\n      deprecatedOption('stale', 'allowStale');\n    }\n\n    if (maxAge) {\n      deprecatedOption('maxAge', 'ttl');\n    }\n\n    if (length) {\n      deprecatedOption('length', 'sizeCalculation');\n    }\n  }\n\n  getRemainingTTL(key) {\n    return this.has(key, {\n      updateAgeOnHas: false\n    }) ? Infinity : 0;\n  }\n\n  initializeTTLTracking() {\n    var _this = this;\n\n    this.ttls = new ZeroArray(this.max);\n    this.starts = new ZeroArray(this.max);\n\n    this.setItemTTL = function (index, ttl) {\n      let start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : perf.now();\n      _this.starts[index] = ttl !== 0 ? start : 0;\n      _this.ttls[index] = ttl;\n\n      if (ttl !== 0 && _this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (_this.isStale(index)) {\n            _this.delete(_this.keyList[index]);\n          }\n        }, ttl + 1);\n        /* istanbul ignore else - unref() not supported on all platforms */\n\n        if (t.unref) {\n          t.unref();\n        }\n      }\n    };\n\n    this.updateItemAge = index => {\n      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;\n    }; // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n\n\n    let cachedNow = 0;\n\n    const getNow = () => {\n      const n = perf.now();\n\n      if (this.ttlResolution > 0) {\n        cachedNow = n;\n        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);\n        /* istanbul ignore else - not available on all platforms */\n\n        if (t.unref) {\n          t.unref();\n        }\n      }\n\n      return n;\n    };\n\n    this.getRemainingTTL = key => {\n      const index = this.keyMap.get(key);\n\n      if (index === undefined) {\n        return 0;\n      }\n\n      return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());\n    };\n\n    this.isStale = index => {\n      return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];\n    };\n  }\n\n  updateItemAge(index) {}\n\n  setItemTTL(index, ttl, start) {}\n\n  isStale(index) {\n    return false;\n  }\n\n  initializeSizeTracking() {\n    this.calculatedSize = 0;\n    this.sizes = new ZeroArray(this.max);\n\n    this.removeItemSize = index => {\n      this.calculatedSize -= this.sizes[index];\n      this.sizes[index] = 0;\n    };\n\n    this.requireSize = (k, v, size, sizeCalculation) => {\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function');\n          }\n\n          size = sizeCalculation(v, k);\n\n          if (!isPosInt(size)) {\n            throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n          }\n        } else {\n          throw new TypeError('invalid size value (must be positive integer)');\n        }\n      }\n\n      return size;\n    };\n\n    this.addItemSize = (index, size) => {\n      this.sizes[index] = size;\n      const maxSize = this.maxSize - this.sizes[index];\n\n      while (this.calculatedSize > maxSize) {\n        this.evict(true);\n      }\n\n      this.calculatedSize += this.sizes[index];\n    };\n  }\n\n  removeItemSize(index) {}\n\n  addItemSize(index, size) {}\n\n  requireSize(k, v, size, sizeCalculation) {\n    if (size || sizeCalculation) {\n      throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n    }\n  }\n\n  *indexes() {\n    let {\n      allowStale = this.allowStale\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.size) {\n      for (let i = this.tail; true;) {\n        if (!this.isValidIndex(i)) {\n          break;\n        }\n\n        if (allowStale || !this.isStale(i)) {\n          yield i;\n        }\n\n        if (i === this.head) {\n          break;\n        } else {\n          i = this.prev[i];\n        }\n      }\n    }\n  }\n\n  *rindexes() {\n    let {\n      allowStale = this.allowStale\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.size) {\n      for (let i = this.head; true;) {\n        if (!this.isValidIndex(i)) {\n          break;\n        }\n\n        if (allowStale || !this.isStale(i)) {\n          yield i;\n        }\n\n        if (i === this.tail) {\n          break;\n        } else {\n          i = this.next[i];\n        }\n      }\n    }\n  }\n\n  isValidIndex(index) {\n    return this.keyMap.get(this.keyList[index]) === index;\n  }\n\n  *entries() {\n    for (const i of this.indexes()) {\n      yield [this.keyList[i], this.valList[i]];\n    }\n  }\n\n  *rentries() {\n    for (const i of this.rindexes()) {\n      yield [this.keyList[i], this.valList[i]];\n    }\n  }\n\n  *keys() {\n    for (const i of this.indexes()) {\n      yield this.keyList[i];\n    }\n  }\n\n  *rkeys() {\n    for (const i of this.rindexes()) {\n      yield this.keyList[i];\n    }\n  }\n\n  *values() {\n    for (const i of this.indexes()) {\n      yield this.valList[i];\n    }\n  }\n\n  *rvalues() {\n    for (const i of this.rindexes()) {\n      yield this.valList[i];\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  find(fn) {\n    let getOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (const i of this.indexes()) {\n      if (fn(this.valList[i], this.keyList[i], this)) {\n        return this.get(this.keyList[i], getOptions);\n      }\n    }\n  }\n\n  forEach(fn) {\n    let thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\n    for (const i of this.indexes()) {\n      fn.call(thisp, this.valList[i], this.keyList[i], this);\n    }\n  }\n\n  rforEach(fn) {\n    let thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\n    for (const i of this.rindexes()) {\n      fn.call(thisp, this.valList[i], this.keyList[i], this);\n    }\n  }\n\n  get prune() {\n    deprecatedMethod('prune', 'purgeStale');\n    return this.purgeStale;\n  }\n\n  purgeStale() {\n    let deleted = false;\n\n    for (const i of this.rindexes({\n      allowStale: true\n    })) {\n      if (this.isStale(i)) {\n        this.delete(this.keyList[i]);\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  dump() {\n    const arr = [];\n\n    for (const i of this.indexes({\n      allowStale: true\n    })) {\n      const key = this.keyList[i];\n      const v = this.valList[i];\n      const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n      const entry = {\n        value\n      };\n\n      if (this.ttls) {\n        entry.ttl = this.ttls[i]; // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n\n        const age = perf.now() - this.starts[i];\n        entry.start = Math.floor(Date.now() - age);\n      }\n\n      if (this.sizes) {\n        entry.size = this.sizes[i];\n      }\n\n      arr.unshift([key, entry]);\n    }\n\n    return arr;\n  }\n\n  load(arr) {\n    this.clear();\n\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset.\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start;\n        entry.start = perf.now() - age;\n      }\n\n      this.set(key, entry.value, entry);\n    }\n  }\n\n  dispose(v, k, reason) {}\n\n  set(k, v) {\n    let {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    size = this.requireSize(k, v, size, sizeCalculation); // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      return this;\n    }\n\n    let index = this.size === 0 ? undefined : this.keyMap.get(k);\n\n    if (index === undefined) {\n      // addition\n      index = this.newIndex();\n      this.keyList[index] = k;\n      this.valList[index] = v;\n      this.keyMap.set(k, index);\n      this.next[this.tail] = index;\n      this.prev[index] = this.tail;\n      this.tail = index;\n      this.size++;\n      this.addItemSize(index, size);\n      noUpdateTTL = false;\n    } else {\n      // update\n      const oldVal = this.valList[index];\n\n      if (v !== oldVal) {\n        if (this.isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort();\n        } else {\n          if (!noDisposeOnSet) {\n            this.dispose(oldVal, k, 'set');\n\n            if (this.disposeAfter) {\n              this.disposed.push([oldVal, k, 'set']);\n            }\n          }\n        }\n\n        this.removeItemSize(index);\n        this.valList[index] = v;\n        this.addItemSize(index, size);\n      }\n\n      this.moveToTail(index);\n    }\n\n    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {\n      this.initializeTTLTracking();\n    }\n\n    if (!noUpdateTTL) {\n      this.setItemTTL(index, ttl, start);\n    }\n\n    if (this.disposeAfter) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n\n    return this;\n  }\n\n  newIndex() {\n    if (this.size === 0) {\n      return this.tail;\n    }\n\n    if (this.size === this.max && this.max !== 0) {\n      return this.evict(false);\n    }\n\n    if (this.free.length !== 0) {\n      return this.free.pop();\n    } // initial fill, just keep writing down the list\n\n\n    return this.initialFill++;\n  }\n\n  pop() {\n    if (this.size) {\n      const val = this.valList[this.head];\n      this.evict(true);\n      return val;\n    }\n  }\n\n  evict(free) {\n    const head = this.head;\n    const k = this.keyList[head];\n    const v = this.valList[head];\n\n    if (this.isBackgroundFetch(v)) {\n      v.__abortController.abort();\n    } else {\n      this.dispose(v, k, 'evict');\n\n      if (this.disposeAfter) {\n        this.disposed.push([v, k, 'evict']);\n      }\n    }\n\n    this.removeItemSize(head); // if we aren't about to use the index, then null these out\n\n    if (free) {\n      this.keyList[head] = null;\n      this.valList[head] = null;\n      this.free.push(head);\n    }\n\n    this.head = this.next[head];\n    this.keyMap.delete(k);\n    this.size--;\n    return head;\n  }\n\n  has(k) {\n    let {\n      updateAgeOnHas = this.updateAgeOnHas\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.keyMap.get(k);\n\n    if (index !== undefined) {\n      if (!this.isStale(index)) {\n        if (updateAgeOnHas) {\n          this.updateItemAge(index);\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  } // like get(), but without any LRU updating or TTL expiration\n\n\n  peek(k) {\n    let {\n      allowStale = this.allowStale\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.keyMap.get(k);\n\n    if (index !== undefined && (allowStale || !this.isStale(index))) {\n      const v = this.valList[index]; // either stale and allowed, or forcing a refresh of non-stale value\n\n      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n  }\n\n  backgroundFetch(k, index, options, context) {\n    const v = index === undefined ? undefined : this.valList[index];\n\n    if (this.isBackgroundFetch(v)) {\n      return v;\n    }\n\n    const ac = new AC();\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context\n    };\n\n    const cb = v => {\n      if (!ac.signal.aborted) {\n        this.set(k, v, fetchOpts.options);\n      }\n\n      return v;\n    };\n\n    const eb = er => {\n      if (this.valList[index] === p) {\n        const del = !options.noDeleteOnFetchRejection || p.__staleWhileFetching === undefined;\n\n        if (del) {\n          this.delete(k);\n        } else {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          this.valList[index] = p.__staleWhileFetching;\n        }\n      }\n\n      if (p.__returned === p) {\n        throw er;\n      }\n    };\n\n    const pcall = res => res(this.fetchMethod(k, v, fetchOpts));\n\n    const p = new Promise(pcall).then(cb, eb);\n    p.__abortController = ac;\n    p.__staleWhileFetching = v;\n    p.__returned = null;\n\n    if (index === undefined) {\n      this.set(k, p, fetchOpts.options);\n      index = this.keyMap.get(k);\n    } else {\n      this.valList[index] = p;\n    }\n\n    return p;\n  }\n\n  isBackgroundFetch(p) {\n    return p && typeof p === 'object' && typeof p.then === 'function' && Object.prototype.hasOwnProperty.call(p, '__staleWhileFetching') && Object.prototype.hasOwnProperty.call(p, '__returned') && (p.__returned === p || p.__returned === null);\n  } // this takes the union of get() and set() opts, because it does both\n\n\n  async fetch(k) {\n    let {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      fetchContext = this.fetchContext,\n      forceRefresh = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this.fetchMethod) {\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet\n      });\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection\n    };\n    let index = this.keyMap.get(k);\n\n    if (index === undefined) {\n      const p = this.backgroundFetch(k, index, options, fetchContext);\n      return p.__returned = p;\n    } else {\n      // in cache, maybe already fetching\n      const v = this.valList[index];\n\n      if (this.isBackgroundFetch(v)) {\n        return allowStale && v.__staleWhileFetching !== undefined ? v.__staleWhileFetching : v.__returned = v;\n      } // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n\n\n      if (!forceRefresh && !this.isStale(index)) {\n        this.moveToTail(index);\n\n        if (updateAgeOnGet) {\n          this.updateItemAge(index);\n        }\n\n        return v;\n      } // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n\n\n      const p = this.backgroundFetch(k, index, options, fetchContext);\n      return allowStale && p.__staleWhileFetching !== undefined ? p.__staleWhileFetching : p.__returned = p;\n    }\n  }\n\n  get(k) {\n    let {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.keyMap.get(k);\n\n    if (index !== undefined) {\n      const value = this.valList[index];\n      const fetching = this.isBackgroundFetch(value);\n\n      if (this.isStale(index)) {\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k);\n          }\n\n          return allowStale ? value : undefined;\n        } else {\n          return allowStale ? value.__staleWhileFetching : undefined;\n        }\n      } else {\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching,\n        // so we just return undefined\n        if (fetching) {\n          return undefined;\n        }\n\n        this.moveToTail(index);\n\n        if (updateAgeOnGet) {\n          this.updateItemAge(index);\n        }\n\n        return value;\n      }\n    }\n  }\n\n  connect(p, n) {\n    this.prev[n] = p;\n    this.next[p] = n;\n  }\n\n  moveToTail(index) {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.tail) {\n      if (index === this.head) {\n        this.head = this.next[index];\n      } else {\n        this.connect(this.prev[index], this.next[index]);\n      }\n\n      this.connect(this.tail, index);\n      this.tail = index;\n    }\n  }\n\n  get del() {\n    deprecatedMethod('del', 'delete');\n    return this.delete;\n  }\n\n  delete(k) {\n    let deleted = false;\n\n    if (this.size !== 0) {\n      const index = this.keyMap.get(k);\n\n      if (index !== undefined) {\n        deleted = true;\n\n        if (this.size === 1) {\n          this.clear();\n        } else {\n          this.removeItemSize(index);\n          const v = this.valList[index];\n\n          if (this.isBackgroundFetch(v)) {\n            v.__abortController.abort();\n          } else {\n            this.dispose(v, k, 'delete');\n\n            if (this.disposeAfter) {\n              this.disposed.push([v, k, 'delete']);\n            }\n          }\n\n          this.keyMap.delete(k);\n          this.keyList[index] = null;\n          this.valList[index] = null;\n\n          if (index === this.tail) {\n            this.tail = this.prev[index];\n          } else if (index === this.head) {\n            this.head = this.next[index];\n          } else {\n            this.next[this.prev[index]] = this.next[index];\n            this.prev[this.next[index]] = this.prev[index];\n          }\n\n          this.size--;\n          this.free.push(index);\n        }\n      }\n    }\n\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n\n    return deleted;\n  }\n\n  clear() {\n    for (const index of this.rindexes({\n      allowStale: true\n    })) {\n      const v = this.valList[index];\n\n      if (this.isBackgroundFetch(v)) {\n        v.__abortController.abort();\n      } else {\n        const k = this.keyList[index];\n        this.dispose(v, k, 'delete');\n\n        if (this.disposeAfter) {\n          this.disposed.push([v, k, 'delete']);\n        }\n      }\n    }\n\n    this.keyMap.clear();\n    this.valList.fill(null);\n    this.keyList.fill(null);\n\n    if (this.ttls) {\n      this.ttls.fill(0);\n      this.starts.fill(0);\n    }\n\n    if (this.sizes) {\n      this.sizes.fill(0);\n    }\n\n    this.head = 0;\n    this.tail = 0;\n    this.initialFill = 1;\n    this.free.length = 0;\n    this.calculatedSize = 0;\n    this.size = 0;\n\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n  }\n\n  get reset() {\n    deprecatedMethod('reset', 'clear');\n    return this.clear;\n  }\n\n  get length() {\n    deprecatedProperty('length', 'size');\n    return this.size;\n  }\n\n  static get AbortController() {\n    return AC;\n  }\n\n  static get AbortSignal() {\n    return AS;\n  }\n\n}\n\nmodule.exports = LRUCache;","map":{"version":3,"names":["perf","performance","now","Date","hasAbortController","AbortController","AC","constructor","signal","AS","abort","dispatchEvent","hasAbortSignal","AbortSignal","hasACAbortSignal","aborted","_listeners","type","e","target","onabort","forEach","f","addEventListener","ev","fn","push","removeEventListener","filter","warned","Set","deprecatedOption","opt","instead","code","shouldWarn","warn","LRUCache","deprecatedMethod","method","prototype","get","Object","getOwnPropertyDescriptor","deprecatedProperty","field","emitWarning","process","console","error","has","what","add","msg","isPosInt","n","Math","floor","isFinite","getUintArray","max","pow","Uint8Array","Uint16Array","Uint32Array","Number","MAX_SAFE_INTEGER","ZeroArray","Array","size","fill","Stack","UintArray","heap","length","pop","options","ttl","ttlResolution","ttlAutopurge","updateAgeOnGet","updateAgeOnHas","allowStale","dispose","disposeAfter","noDisposeOnSet","noUpdateTTL","maxSize","maxEntrySize","sizeCalculation","fetchMethod","fetchContext","noDeleteOnFetchRejection","noDeleteOnStaleGet","maxAge","stale","TypeError","Error","undefined","keyMap","Map","keyList","valList","next","prev","head","tail","free","initialFill","disposed","initializeSizeTracking","initializeTTLTracking","getRemainingTTL","key","Infinity","ttls","starts","setItemTTL","index","start","t","setTimeout","isStale","delete","unref","updateItemAge","cachedNow","getNow","calculatedSize","sizes","removeItemSize","requireSize","k","v","addItemSize","evict","indexes","i","isValidIndex","rindexes","entries","rentries","keys","rkeys","values","rvalues","Symbol","iterator","find","getOptions","thisp","call","rforEach","prune","purgeStale","deleted","dump","arr","value","isBackgroundFetch","__staleWhileFetching","entry","age","unshift","load","clear","set","reason","newIndex","oldVal","__abortController","moveToTail","shift","val","peek","backgroundFetch","context","ac","fetchOpts","cb","eb","er","p","del","__returned","pcall","res","Promise","then","hasOwnProperty","fetch","forceRefresh","fetching","connect","reset","module","exports"],"sources":["/Users/dewan03/project/project/node_modules/@mui/x-data-grid-generator/node_modules/lru-cache/index.js"],"sourcesContent":["const perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst hasAbortController = typeof AbortController === 'function'\n\n// minimal backwards-compatibility polyfill\n// this doesn't have nearly all the checks and whatnot that\n// actual AbortController/Signal has, but it's enough for\n// our purposes, and if used properly, behaves the same.\nconst AC = hasAbortController\n  ? AbortController\n  : class AbortController {\n      constructor() {\n        this.signal = new AS()\n      }\n      abort() {\n        this.signal.dispatchEvent('abort')\n      }\n    }\n\nconst hasAbortSignal = typeof AbortSignal === 'function'\n// Some polyfills put this on the AC class, not global\nconst hasACAbortSignal = typeof AC.AbortSignal === 'function'\nconst AS = hasAbortSignal\n  ? AbortSignal\n  : hasACAbortSignal\n  ? AC.AbortController\n  : class AbortSignal {\n      constructor() {\n        this.aborted = false\n        this._listeners = []\n      }\n      dispatchEvent(type) {\n        if (type === 'abort') {\n          this.aborted = true\n          const e = { type, target: this }\n          this.onabort(e)\n          this._listeners.forEach(f => f(e), this)\n        }\n      }\n      onabort() {}\n      addEventListener(ev, fn) {\n        if (ev === 'abort') {\n          this._listeners.push(fn)\n        }\n      }\n      removeEventListener(ev, fn) {\n        if (ev === 'abort') {\n          this._listeners = this._listeners.filter(f => f !== fn)\n        }\n      }\n    }\n\nconst warned = new Set()\nconst deprecatedOption = (opt, instead) => {\n  const code = `LRU_CACHE_OPTION_${opt}`\n  if (shouldWarn(code)) {\n    warn(code, `${opt} option`, `options.${instead}`, LRUCache)\n  }\n}\nconst deprecatedMethod = (method, instead) => {\n  const code = `LRU_CACHE_METHOD_${method}`\n  if (shouldWarn(code)) {\n    const { prototype } = LRUCache\n    const { get } = Object.getOwnPropertyDescriptor(prototype, method)\n    warn(code, `${method} method`, `cache.${instead}()`, get)\n  }\n}\nconst deprecatedProperty = (field, instead) => {\n  const code = `LRU_CACHE_PROPERTY_${field}`\n  if (shouldWarn(code)) {\n    const { prototype } = LRUCache\n    const { get } = Object.getOwnPropertyDescriptor(prototype, field)\n    warn(code, `${field} property`, `cache.${instead}`, get)\n  }\n}\n\nconst emitWarning = (...a) => {\n  typeof process === 'object' &&\n  process &&\n  typeof process.emitWarning === 'function'\n    ? process.emitWarning(...a)\n    : console.error(...a)\n}\n\nconst shouldWarn = code => !warned.has(code)\n\nconst warn = (code, what, instead, fn) => {\n  warned.add(code)\n  const msg = `The ${what} is deprecated. Please use ${instead} instead.`\n  emitWarning(msg, 'DeprecationWarning', code, fn)\n}\n\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)\n\n/* istanbul ignore next - This is a little bit ridiculous, tbh.\n * The maximum array length is 2^32-1 or thereabouts on most JS impls.\n * And well before that point, you're caching the entire world, I mean,\n * that's ~32GB of just integers for the next/prev links, plus whatever\n * else to hold that many keys and values.  Just filling the memory with\n * zeroes at init time is brutal when you get that big.\n * But why not be complete?\n * Maybe in the future, these limits will have expanded. */\nconst getUintArray = max =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size)\n    this.fill(0)\n  }\n}\n\nclass Stack {\n  constructor(max) {\n    if (max === 0) {\n      return []\n    }\n    const UintArray = getUintArray(max)\n    this.heap = new UintArray(max)\n    this.length = 0\n  }\n  push(n) {\n    this.heap[this.length++] = n\n  }\n  pop() {\n    return this.heap[--this.length]\n  }\n}\n\nclass LRUCache {\n  constructor(options = {}) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      fetchContext,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n    } = options\n\n    // deprecated options, don't trigger a warning for getting them if\n    // the thing being passed in is another LRUCache we're copying.\n    const { length, maxAge, stale } =\n      options instanceof LRUCache ? {} : options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.max = max\n    this.maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.maxSize\n    this.sizeCalculation = sizeCalculation || length\n    if (this.sizeCalculation) {\n      if (!this.maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    this.fetchMethod = fetchMethod || null\n    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n\n    this.fetchContext = fetchContext\n    if (!this.fetchMethod && fetchContext !== undefined) {\n      throw new TypeError(\n        'cannot set fetchContext without fetchMethod'\n      )\n    }\n\n    this.keyMap = new Map()\n    this.keyList = new Array(max).fill(null)\n    this.valList = new Array(max).fill(null)\n    this.next = new UintArray(max)\n    this.prev = new UintArray(max)\n    this.head = 0\n    this.tail = 0\n    this.free = new Stack(max)\n    this.initialFill = 1\n    this.size = 0\n\n    if (typeof dispose === 'function') {\n      this.dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.disposeAfter = disposeAfter\n      this.disposed = []\n    } else {\n      this.disposeAfter = null\n      this.disposed = null\n    }\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.maxSize !== 0) {\n        if (!isPosInt(this.maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale || !!stale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || maxAge || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n\n    if (stale) {\n      deprecatedOption('stale', 'allowStale')\n    }\n    if (maxAge) {\n      deprecatedOption('maxAge', 'ttl')\n    }\n    if (length) {\n      deprecatedOption('length', 'sizeCalculation')\n    }\n  }\n\n  getRemainingTTL(key) {\n    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0\n  }\n\n  initializeTTLTracking() {\n    this.ttls = new ZeroArray(this.max)\n    this.starts = new ZeroArray(this.max)\n\n    this.setItemTTL = (index, ttl, start = perf.now()) => {\n      this.starts[index] = ttl !== 0 ? start : 0\n      this.ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.isStale(index)) {\n            this.delete(this.keyList[index])\n          }\n        }, ttl + 1)\n        /* istanbul ignore else - unref() not supported on all platforms */\n        if (t.unref) {\n          t.unref()\n        }\n      }\n    }\n\n    this.updateItemAge = index => {\n      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        /* istanbul ignore else - not available on all platforms */\n        if (t.unref) {\n          t.unref()\n        }\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      return this.ttls[index] === 0 || this.starts[index] === 0\n        ? Infinity\n        : this.starts[index] +\n            this.ttls[index] -\n            (cachedNow || getNow())\n    }\n\n    this.isStale = index => {\n      return (\n        this.ttls[index] !== 0 &&\n        this.starts[index] !== 0 &&\n        (cachedNow || getNow()) - this.starts[index] >\n          this.ttls[index]\n      )\n    }\n  }\n  updateItemAge(index) {}\n  setItemTTL(index, ttl, start) {}\n  isStale(index) {\n    return false\n  }\n\n  initializeSizeTracking() {\n    this.calculatedSize = 0\n    this.sizes = new ZeroArray(this.max)\n    this.removeItemSize = index => {\n      this.calculatedSize -= this.sizes[index]\n      this.sizes[index] = 0\n    }\n    this.requireSize = (k, v, size, sizeCalculation) => {\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer)'\n          )\n        }\n      }\n      return size\n    }\n    this.addItemSize = (index, size) => {\n      this.sizes[index] = size\n      const maxSize = this.maxSize - this.sizes[index]\n      while (this.calculatedSize > maxSize) {\n        this.evict(true)\n      }\n      this.calculatedSize += this.sizes[index]\n    }\n  }\n  removeItemSize(index) {}\n  addItemSize(index, size) {}\n  requireSize(k, v, size, sizeCalculation) {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n  }\n\n  *indexes({ allowStale = this.allowStale } = {}) {\n    if (this.size) {\n      for (let i = this.tail; true; ) {\n        if (!this.isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.isStale(i)) {\n          yield i\n        }\n        if (i === this.head) {\n          break\n        } else {\n          i = this.prev[i]\n        }\n      }\n    }\n  }\n\n  *rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.size) {\n      for (let i = this.head; true; ) {\n        if (!this.isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.isStale(i)) {\n          yield i\n        }\n        if (i === this.tail) {\n          break\n        } else {\n          i = this.next[i]\n        }\n      }\n    }\n  }\n\n  isValidIndex(index) {\n    return this.keyMap.get(this.keyList[index]) === index\n  }\n\n  *entries() {\n    for (const i of this.indexes()) {\n      yield [this.keyList[i], this.valList[i]]\n    }\n  }\n  *rentries() {\n    for (const i of this.rindexes()) {\n      yield [this.keyList[i], this.valList[i]]\n    }\n  }\n\n  *keys() {\n    for (const i of this.indexes()) {\n      yield this.keyList[i]\n    }\n  }\n  *rkeys() {\n    for (const i of this.rindexes()) {\n      yield this.keyList[i]\n    }\n  }\n\n  *values() {\n    for (const i of this.indexes()) {\n      yield this.valList[i]\n    }\n  }\n  *rvalues() {\n    for (const i of this.rindexes()) {\n      yield this.valList[i]\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  find(fn, getOptions = {}) {\n    for (const i of this.indexes()) {\n      if (fn(this.valList[i], this.keyList[i], this)) {\n        return this.get(this.keyList[i], getOptions)\n      }\n    }\n  }\n\n  forEach(fn, thisp = this) {\n    for (const i of this.indexes()) {\n      fn.call(thisp, this.valList[i], this.keyList[i], this)\n    }\n  }\n\n  rforEach(fn, thisp = this) {\n    for (const i of this.rindexes()) {\n      fn.call(thisp, this.valList[i], this.keyList[i], this)\n    }\n  }\n\n  get prune() {\n    deprecatedMethod('prune', 'purgeStale')\n    return this.purgeStale\n  }\n\n  purgeStale() {\n    let deleted = false\n    for (const i of this.rindexes({ allowStale: true })) {\n      if (this.isStale(i)) {\n        this.delete(this.keyList[i])\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  dump() {\n    const arr = []\n    for (const i of this.indexes({ allowStale: true })) {\n      const key = this.keyList[i]\n      const v = this.valList[i]\n      const value = this.isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      const entry = { value }\n      if (this.ttls) {\n        entry.ttl = this.ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - this.starts[i]\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.sizes) {\n        entry.size = this.sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  load(arr) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset.\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  dispose(v, k, reason) {}\n\n  set(\n    k,\n    v,\n    {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n    } = {}\n  ) {\n    size = this.requireSize(k, v, size, sizeCalculation)\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      return this\n    }\n    let index = this.size === 0 ? undefined : this.keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = this.newIndex()\n      this.keyList[index] = k\n      this.valList[index] = v\n      this.keyMap.set(k, index)\n      this.next[this.tail] = index\n      this.prev[index] = this.tail\n      this.tail = index\n      this.size++\n      this.addItemSize(index, size)\n      noUpdateTTL = false\n    } else {\n      // update\n      const oldVal = this.valList[index]\n      if (v !== oldVal) {\n        if (this.isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort()\n        } else {\n          if (!noDisposeOnSet) {\n            this.dispose(oldVal, k, 'set')\n            if (this.disposeAfter) {\n              this.disposed.push([oldVal, k, 'set'])\n            }\n          }\n        }\n        this.removeItemSize(index)\n        this.valList[index] = v\n        this.addItemSize(index, size)\n      }\n      this.moveToTail(index)\n    }\n    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {\n      this.initializeTTLTracking()\n    }\n    if (!noUpdateTTL) {\n      this.setItemTTL(index, ttl, start)\n    }\n    if (this.disposeAfter) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n    return this\n  }\n\n  newIndex() {\n    if (this.size === 0) {\n      return this.tail\n    }\n    if (this.size === this.max && this.max !== 0) {\n      return this.evict(false)\n    }\n    if (this.free.length !== 0) {\n      return this.free.pop()\n    }\n    // initial fill, just keep writing down the list\n    return this.initialFill++\n  }\n\n  pop() {\n    if (this.size) {\n      const val = this.valList[this.head]\n      this.evict(true)\n      return val\n    }\n  }\n\n  evict(free) {\n    const head = this.head\n    const k = this.keyList[head]\n    const v = this.valList[head]\n    if (this.isBackgroundFetch(v)) {\n      v.__abortController.abort()\n    } else {\n      this.dispose(v, k, 'evict')\n      if (this.disposeAfter) {\n        this.disposed.push([v, k, 'evict'])\n      }\n    }\n    this.removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.keyList[head] = null\n      this.valList[head] = null\n      this.free.push(head)\n    }\n    this.head = this.next[head]\n    this.keyMap.delete(k)\n    this.size--\n    return head\n  }\n\n  has(k, { updateAgeOnHas = this.updateAgeOnHas } = {}) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined) {\n      if (!this.isStale(index)) {\n        if (updateAgeOnHas) {\n          this.updateItemAge(index)\n        }\n        return true\n      }\n    }\n    return false\n  }\n\n  // like get(), but without any LRU updating or TTL expiration\n  peek(k, { allowStale = this.allowStale } = {}) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined && (allowStale || !this.isStale(index))) {\n      const v = this.valList[index]\n      // either stale and allowed, or forcing a refresh of non-stale value\n      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v\n    }\n  }\n\n  backgroundFetch(k, index, options, context) {\n    const v = index === undefined ? undefined : this.valList[index]\n    if (this.isBackgroundFetch(v)) {\n      return v\n    }\n    const ac = new AC()\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n    const cb = v => {\n      if (!ac.signal.aborted) {\n        this.set(k, v, fetchOpts.options)\n      }\n      return v\n    }\n    const eb = er => {\n      if (this.valList[index] === p) {\n        const del =\n          !options.noDeleteOnFetchRejection ||\n          p.__staleWhileFetching === undefined\n        if (del) {\n          this.delete(k)\n        } else {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          this.valList[index] = p.__staleWhileFetching\n        }\n      }\n      if (p.__returned === p) {\n        throw er\n      }\n    }\n    const pcall = res => res(this.fetchMethod(k, v, fetchOpts))\n    const p = new Promise(pcall).then(cb, eb)\n    p.__abortController = ac\n    p.__staleWhileFetching = v\n    p.__returned = null\n    if (index === undefined) {\n      this.set(k, p, fetchOpts.options)\n      index = this.keyMap.get(k)\n    } else {\n      this.valList[index] = p\n    }\n    return p\n  }\n\n  isBackgroundFetch(p) {\n    return (\n      p &&\n      typeof p === 'object' &&\n      typeof p.then === 'function' &&\n      Object.prototype.hasOwnProperty.call(\n        p,\n        '__staleWhileFetching'\n      ) &&\n      Object.prototype.hasOwnProperty.call(p, '__returned') &&\n      (p.__returned === p || p.__returned === null)\n    )\n  }\n\n  // this takes the union of get() and set() opts, because it does both\n  async fetch(\n    k,\n    {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      fetchContext = this.fetchContext,\n      forceRefresh = false,\n    } = {}\n  ) {\n    if (!this.fetchMethod) {\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n    }\n\n    let index = this.keyMap.get(k)\n    if (index === undefined) {\n      const p = this.backgroundFetch(k, index, options, fetchContext)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.valList[index]\n      if (this.isBackgroundFetch(v)) {\n        return allowStale && v.__staleWhileFetching !== undefined\n          ? v.__staleWhileFetching\n          : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      if (!forceRefresh && !this.isStale(index)) {\n        this.moveToTail(index)\n        if (updateAgeOnGet) {\n          this.updateItemAge(index)\n        }\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.backgroundFetch(k, index, options, fetchContext)\n      return allowStale && p.__staleWhileFetching !== undefined\n        ? p.__staleWhileFetching\n        : (p.__returned = p)\n    }\n  }\n\n  get(\n    k,\n    {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n    } = {}\n  ) {\n    const index = this.keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.valList[index]\n      const fetching = this.isBackgroundFetch(value)\n      if (this.isStale(index)) {\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k)\n          }\n          return allowStale ? value : undefined\n        } else {\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching,\n        // so we just return undefined\n        if (fetching) {\n          return undefined\n        }\n        this.moveToTail(index)\n        if (updateAgeOnGet) {\n          this.updateItemAge(index)\n        }\n        return value\n      }\n    }\n  }\n\n  connect(p, n) {\n    this.prev[n] = p\n    this.next[p] = n\n  }\n\n  moveToTail(index) {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.tail) {\n      if (index === this.head) {\n        this.head = this.next[index]\n      } else {\n        this.connect(this.prev[index], this.next[index])\n      }\n      this.connect(this.tail, index)\n      this.tail = index\n    }\n  }\n\n  get del() {\n    deprecatedMethod('del', 'delete')\n    return this.delete\n  }\n\n  delete(k) {\n    let deleted = false\n    if (this.size !== 0) {\n      const index = this.keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.size === 1) {\n          this.clear()\n        } else {\n          this.removeItemSize(index)\n          const v = this.valList[index]\n          if (this.isBackgroundFetch(v)) {\n            v.__abortController.abort()\n          } else {\n            this.dispose(v, k, 'delete')\n            if (this.disposeAfter) {\n              this.disposed.push([v, k, 'delete'])\n            }\n          }\n          this.keyMap.delete(k)\n          this.keyList[index] = null\n          this.valList[index] = null\n          if (index === this.tail) {\n            this.tail = this.prev[index]\n          } else if (index === this.head) {\n            this.head = this.next[index]\n          } else {\n            this.next[this.prev[index]] = this.next[index]\n            this.prev[this.next[index]] = this.prev[index]\n          }\n          this.size--\n          this.free.push(index)\n        }\n      }\n    }\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n    return deleted\n  }\n\n  clear() {\n    for (const index of this.rindexes({ allowStale: true })) {\n      const v = this.valList[index]\n      if (this.isBackgroundFetch(v)) {\n        v.__abortController.abort()\n      } else {\n        const k = this.keyList[index]\n        this.dispose(v, k, 'delete')\n        if (this.disposeAfter) {\n          this.disposed.push([v, k, 'delete'])\n        }\n      }\n    }\n\n    this.keyMap.clear()\n    this.valList.fill(null)\n    this.keyList.fill(null)\n    if (this.ttls) {\n      this.ttls.fill(0)\n      this.starts.fill(0)\n    }\n    if (this.sizes) {\n      this.sizes.fill(0)\n    }\n    this.head = 0\n    this.tail = 0\n    this.initialFill = 1\n    this.free.length = 0\n    this.calculatedSize = 0\n    this.size = 0\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift())\n      }\n    }\n  }\n\n  get reset() {\n    deprecatedMethod('reset', 'clear')\n    return this.clear\n  }\n\n  get length() {\n    deprecatedProperty('length', 'size')\n    return this.size\n  }\n\n  static get AbortController() {\n    return AC\n  }\n  static get AbortSignal() {\n    return AS\n  }\n}\n\nmodule.exports = LRUCache\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}