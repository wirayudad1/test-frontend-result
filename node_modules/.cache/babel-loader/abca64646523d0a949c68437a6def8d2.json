{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n      _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nimport * as React from 'react';\nimport { GRID_STRING_COL_DEF } from '@mui/x-data-grid-pro';\nimport { GridGroupingColumnFooterCell } from '../../../components/GridGroupingColumnFooterCell';\nimport { GridGroupingCriteriaCell } from '../../../components/GridGroupingCriteriaCell';\nimport { GridGroupingColumnLeafCell } from '../../../components/GridGroupingColumnLeafCell';\nimport { getRowGroupingFieldFromGroupingCriteria, GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD } from './gridRowGroupingUtils';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = _extends({}, GRID_STRING_COL_DEF, {\n  disableReorder: true\n});\n\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  type: 'rowGroupByColumnsGroup',\n  editable: false,\n  groupable: false\n};\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\n\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  const model = gridRowGroupingSanitizedModelSelector(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = cellParams1.rowNode.groupingField;\n  const groupingField2 = cellParams2.rowNode.groupingField;\n\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n\n  if (groupingField1 == null) {\n    return -1;\n  }\n\n  if (groupingField2 == null) {\n    return 1;\n  }\n\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n\n  return 1;\n};\n\nconst getLeafProperties = leafColDef => {\n  var _leafColDef$headerNam, _leafColDef$filterOpe;\n\n  return {\n    headerName: (_leafColDef$headerNam = leafColDef.headerName) != null ? _leafColDef$headerNam : leafColDef.field,\n    sortable: leafColDef.sortable,\n    filterable: leafColDef.filterable,\n    filterOperators: (_leafColDef$filterOpe = leafColDef.filterOperators) == null ? void 0 : _leafColDef$filterOpe.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          return originalFn(params);\n        };\n      }\n    })),\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the leaves\n      if (cellParams1.rowNode.groupingField === null && cellParams2.rowNode.groupingField === null) {\n        return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    }\n  };\n};\n\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  var _groupedByColDef$filt;\n\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.groupingField === groupedByColDef.field && cellParams2.rowNode.groupingField === groupedByColDef.field) {\n        return groupedByColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: (_groupedByColDef$filt = groupedByColDef.filterOperators) == null ? void 0 : _groupedByColDef$filt.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          return originalFn(params);\n        };\n      }\n    }))\n  };\n\n  if (applyHeaderName) {\n    var _groupedByColDef$head;\n\n    properties.headerName = (_groupedByColDef$head = groupedByColDef.headerName) != null ? _groupedByColDef$head : groupedByColDef.field;\n  }\n\n  return properties;\n};\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\n\n\nexport const createGroupingColDefForOneGroupingCriteria = _ref3 => {\n  let {\n    columnsLookup,\n    groupedByColDef,\n    groupingCriteria,\n    colDefOverride\n  } = _ref3;\n\n  var _groupedByColDef$widt, _leafColDef$width;\n\n  const _ref = colDefOverride != null ? colDefOverride : {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    width: Math.max(((_groupedByColDef$widt = groupedByColDef.width) != null ? _groupedByColDef$widt : GRID_STRING_COL_DEF.width) + 40, (_leafColDef$width = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.position === 'footer') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      } // Render leaves\n\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render current grouping criteria groups\n\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n\n      return '';\n    },\n    valueGetter: params => {\n      if (!params.rowNode) {\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return params.rowNode.groupingKey;\n      }\n\n      return undefined;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: getRowGroupingFieldFromGroupingCriteria(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\n\nexport const createGroupingColDefForAllGroupingCriteria = _ref4 => {\n  let {\n    apiRef,\n    columnsLookup,\n    rowGroupingModel,\n    colDefOverride\n  } = _ref4;\n\n  var _leafColDef$width2;\n\n  const _ref2 = colDefOverride != null ? colDefOverride : {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref2,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => {\n      var _columnsLookup$field$;\n\n      return ((_columnsLookup$field$ = columnsLookup[field].width) != null ? _columnsLookup$field$ : GRID_STRING_COL_DEF.width) + 40;\n    }), (_leafColDef$width2 = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width2 : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.position === 'footer') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      } // Render the leaves\n\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render the groups\n\n\n      return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: params => {\n      if (!params.rowNode) {\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n\n        return undefined;\n      }\n\n      return params.rowNode.groupingKey;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_extends","_excluded","_excluded2","React","GRID_STRING_COL_DEF","GridGroupingColumnFooterCell","GridGroupingCriteriaCell","GridGroupingColumnLeafCell","getRowGroupingFieldFromGroupingCriteria","GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD","gridRowGroupingSanitizedModelSelector","jsx","_jsx","GROUPING_COL_DEF_DEFAULT_PROPERTIES","disableReorder","GROUPING_COL_DEF_FORCED_PROPERTIES","type","editable","groupable","groupingFieldIndexComparator","v1","v2","cellParams1","cellParams2","model","api","state","instanceId","groupingField1","rowNode","groupingField","groupingField2","indexOf","getLeafProperties","leafColDef","_leafColDef$headerNam","_leafColDef$filterOpe","headerName","field","sortable","filterable","filterOperators","map","operator","getApplyFilterFn","filterItem","column","originalFn","params","sortComparator","getGroupingCriteriaProperties","groupedByColDef","applyHeaderName","_groupedByColDef$filt","properties","_groupedByColDef$head","createGroupingColDefForOneGroupingCriteria","columnsLookup","groupingCriteria","colDefOverride","_groupedByColDef$widt","_leafColDef$width","_ref","leafField","mainGroupingCriteria","hideDescendantCount","colDefOverrideProperties","commonProperties","width","Math","max","renderCell","position","leafParams","getCellParams","id","valueGetter","undefined","getCellValue","groupingKey","sourceProperties","forcedProperties","createGroupingColDefForAllGroupingCriteria","apiRef","rowGroupingModel","_leafColDef$width2","_ref2","current","getLocaleText","_columnsLookup$field$","includes","length"],"sources":["/Users/dewan03/project/project/node_modules/@mui/x-data-grid-premium/hooks/features/rowGrouping/createGroupingColDef.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n      _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nimport * as React from 'react';\nimport { GRID_STRING_COL_DEF } from '@mui/x-data-grid-pro';\nimport { GridGroupingColumnFooterCell } from '../../../components/GridGroupingColumnFooterCell';\nimport { GridGroupingCriteriaCell } from '../../../components/GridGroupingCriteriaCell';\nimport { GridGroupingColumnLeafCell } from '../../../components/GridGroupingColumnLeafCell';\nimport { getRowGroupingFieldFromGroupingCriteria, GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD } from './gridRowGroupingUtils';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = _extends({}, GRID_STRING_COL_DEF, {\n  disableReorder: true\n});\n\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  type: 'rowGroupByColumnsGroup',\n  editable: false,\n  groupable: false\n};\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\n\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  const model = gridRowGroupingSanitizedModelSelector(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = cellParams1.rowNode.groupingField;\n  const groupingField2 = cellParams2.rowNode.groupingField;\n\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n\n  if (groupingField1 == null) {\n    return -1;\n  }\n\n  if (groupingField2 == null) {\n    return 1;\n  }\n\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n\n  return 1;\n};\n\nconst getLeafProperties = leafColDef => {\n  var _leafColDef$headerNam, _leafColDef$filterOpe;\n\n  return {\n    headerName: (_leafColDef$headerNam = leafColDef.headerName) != null ? _leafColDef$headerNam : leafColDef.field,\n    sortable: leafColDef.sortable,\n    filterable: leafColDef.filterable,\n    filterOperators: (_leafColDef$filterOpe = leafColDef.filterOperators) == null ? void 0 : _leafColDef$filterOpe.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          return originalFn(params);\n        };\n      }\n    })),\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the leaves\n      if (cellParams1.rowNode.groupingField === null && cellParams2.rowNode.groupingField === null) {\n        return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    }\n  };\n};\n\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  var _groupedByColDef$filt;\n\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.groupingField === groupedByColDef.field && cellParams2.rowNode.groupingField === groupedByColDef.field) {\n        return groupedByColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: (_groupedByColDef$filt = groupedByColDef.filterOperators) == null ? void 0 : _groupedByColDef$filt.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          return originalFn(params);\n        };\n      }\n    }))\n  };\n\n  if (applyHeaderName) {\n    var _groupedByColDef$head;\n\n    properties.headerName = (_groupedByColDef$head = groupedByColDef.headerName) != null ? _groupedByColDef$head : groupedByColDef.field;\n  }\n\n  return properties;\n};\n\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\nexport const createGroupingColDefForOneGroupingCriteria = ({\n  columnsLookup,\n  groupedByColDef,\n  groupingCriteria,\n  colDefOverride\n}) => {\n  var _groupedByColDef$widt, _leafColDef$width;\n\n  const _ref = colDefOverride != null ? colDefOverride : {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    width: Math.max(((_groupedByColDef$widt = groupedByColDef.width) != null ? _groupedByColDef$widt : GRID_STRING_COL_DEF.width) + 40, (_leafColDef$width = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.position === 'footer') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      } // Render leaves\n\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render current grouping criteria groups\n\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n\n      return '';\n    },\n    valueGetter: params => {\n      if (!params.rowNode) {\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return params.rowNode.groupingKey;\n      }\n\n      return undefined;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: getRowGroupingFieldFromGroupingCriteria(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\nexport const createGroupingColDefForAllGroupingCriteria = ({\n  apiRef,\n  columnsLookup,\n  rowGroupingModel,\n  colDefOverride\n}) => {\n  var _leafColDef$width2;\n\n  const _ref2 = colDefOverride != null ? colDefOverride : {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref2,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => {\n      var _columnsLookup$field$;\n\n      return ((_columnsLookup$field$ = columnsLookup[field].width) != null ? _columnsLookup$field$ : GRID_STRING_COL_DEF.width) + 40;\n    }), (_leafColDef$width2 = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width2 : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.position === 'footer') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      } // Render the leaves\n\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render the groups\n\n\n      return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: params => {\n      if (!params.rowNode) {\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n\n        return undefined;\n      }\n\n      return params.rowNode.groupingKey;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}