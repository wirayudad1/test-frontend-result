{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { gridPinnedColumnsSelector } from './gridColumnPinningSelector';\nimport { columnPinningStateInitializer } from './useGridColumnPinning';\nimport { filterColumns } from '../../../components/DataGridProVirtualScroller';\nexport const useGridColumnPinningPreProcessors = (apiRef, props) => {\n  const {\n    disableColumnPinning,\n    pinnedColumns: pinnedColumnsProp,\n    initialState\n  } = props;\n  let pinnedColumns = gridPinnedColumnsSelector(apiRef.current.state);\n\n  if (pinnedColumns == null) {\n    // Since the state is not ready yet lets use the initializer to get which\n    // columns should be pinned initially.\n    const initializedState = columnPinningStateInitializer(apiRef.current.state, {\n      disableColumnPinning,\n      pinnedColumns: pinnedColumnsProp,\n      initialState\n    }, apiRef);\n    pinnedColumns = gridPinnedColumnsSelector(initializedState);\n  }\n\n  const prevAllPinnedColumns = React.useRef();\n  const reorderPinnedColumns = React.useCallback(columnsState => {\n    if (columnsState.all.length === 0 || disableColumnPinning) {\n      return columnsState;\n    }\n\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, columnsState.all);\n    let newOrderedFields;\n    const allPinnedColumns = [...leftPinnedColumns, ...rightPinnedColumns];\n    const {\n      orderedFieldsBeforePinningColumns\n    } = apiRef.current.unstable_caches.columnPinning;\n\n    if (orderedFieldsBeforePinningColumns) {\n      newOrderedFields = new Array(columnsState.all.length).fill(null);\n      const newOrderedFieldsBeforePinningColumns = [...newOrderedFields]; // Contains the fields not added to the orderedFields array yet\n\n      const remainingFields = [...columnsState.all]; // First, we check if the column was unpinned since the last processing.\n      // If yes and it still exists, we move it back to the same position it was before pinning\n\n      prevAllPinnedColumns.current.forEach(field => {\n        if (!allPinnedColumns.includes(field) && columnsState.lookup[field]) {\n          // Get the position before pinning\n          const index = orderedFieldsBeforePinningColumns.indexOf(field);\n          newOrderedFields[index] = field;\n          newOrderedFieldsBeforePinningColumns[index] = field; // This field was already consumed so we prevent from being added again\n\n          remainingFields.splice(remainingFields.indexOf(field), 1);\n        }\n      }); // For columns still pinned, we keep stored their original positions\n\n      allPinnedColumns.forEach(field => {\n        let index = orderedFieldsBeforePinningColumns.indexOf(field); // If index = -1, the pinned field didn't exist in the last processing, it's possibly being added now\n        // If index >= newOrderedFieldsBeforePinningColumns.length, then one or more columns were removed\n        // In both cases, use the position from the columns array\n        // TODO: detect removed columns and decrease the positions after it\n\n        if (index === -1 || index >= newOrderedFieldsBeforePinningColumns.length) {\n          index = columnsState.all.indexOf(field);\n        } // The fallback above may make the column to be inserted in a position already occupied\n        // In this case, put it in any empty slot available\n\n\n        if (newOrderedFieldsBeforePinningColumns[index] !== null) {\n          index = 0;\n\n          while (newOrderedFieldsBeforePinningColumns[index] !== null) {\n            index += 1;\n          }\n        }\n\n        newOrderedFields[index] = field;\n        newOrderedFieldsBeforePinningColumns[index] = field; // This field was already consumed so we prevent from being added again\n\n        remainingFields.splice(remainingFields.indexOf(field), 1);\n      }); // The fields remaining are those that're neither pinnned nor were unpinned\n      // For these, we spread them across both arrays making sure to not override existing values\n\n      let i = 0;\n      remainingFields.forEach(field => {\n        while (newOrderedFieldsBeforePinningColumns[i] !== null) {\n          i += 1;\n        }\n\n        newOrderedFieldsBeforePinningColumns[i] = field;\n        newOrderedFields[i] = field;\n      });\n      apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;\n    } else {\n      newOrderedFields = [...columnsState.all];\n      apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = [...columnsState.all];\n    }\n\n    prevAllPinnedColumns.current = allPinnedColumns;\n    const centerColumns = newOrderedFields.filter(field => {\n      return !leftPinnedColumns.includes(field) && !rightPinnedColumns.includes(field);\n    });\n    return _extends({}, columnsState, {\n      all: [...leftPinnedColumns, ...centerColumns, ...rightPinnedColumns]\n    });\n  }, [apiRef, disableColumnPinning, pinnedColumns]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateColumns', reorderPinnedColumns);\n};","map":{"version":3,"names":["_extends","React","useGridRegisterPipeProcessor","gridPinnedColumnsSelector","columnPinningStateInitializer","filterColumns","useGridColumnPinningPreProcessors","apiRef","props","disableColumnPinning","pinnedColumns","pinnedColumnsProp","initialState","current","state","initializedState","prevAllPinnedColumns","useRef","reorderPinnedColumns","useCallback","columnsState","all","length","leftPinnedColumns","rightPinnedColumns","newOrderedFields","allPinnedColumns","orderedFieldsBeforePinningColumns","unstable_caches","columnPinning","Array","fill","newOrderedFieldsBeforePinningColumns","remainingFields","forEach","field","includes","lookup","index","indexOf","splice","i","centerColumns","filter"],"sources":["/Users/dewan03/project/project/node_modules/@mui/x-data-grid-pro/hooks/features/columnPinning/useGridColumnPinningPreProcessors.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { gridPinnedColumnsSelector } from './gridColumnPinningSelector';\nimport { columnPinningStateInitializer } from './useGridColumnPinning';\nimport { filterColumns } from '../../../components/DataGridProVirtualScroller';\nexport const useGridColumnPinningPreProcessors = (apiRef, props) => {\n  const {\n    disableColumnPinning,\n    pinnedColumns: pinnedColumnsProp,\n    initialState\n  } = props;\n  let pinnedColumns = gridPinnedColumnsSelector(apiRef.current.state);\n\n  if (pinnedColumns == null) {\n    // Since the state is not ready yet lets use the initializer to get which\n    // columns should be pinned initially.\n    const initializedState = columnPinningStateInitializer(apiRef.current.state, {\n      disableColumnPinning,\n      pinnedColumns: pinnedColumnsProp,\n      initialState\n    }, apiRef);\n    pinnedColumns = gridPinnedColumnsSelector(initializedState);\n  }\n\n  const prevAllPinnedColumns = React.useRef();\n  const reorderPinnedColumns = React.useCallback(columnsState => {\n    if (columnsState.all.length === 0 || disableColumnPinning) {\n      return columnsState;\n    }\n\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, columnsState.all);\n    let newOrderedFields;\n    const allPinnedColumns = [...leftPinnedColumns, ...rightPinnedColumns];\n    const {\n      orderedFieldsBeforePinningColumns\n    } = apiRef.current.unstable_caches.columnPinning;\n\n    if (orderedFieldsBeforePinningColumns) {\n      newOrderedFields = new Array(columnsState.all.length).fill(null);\n      const newOrderedFieldsBeforePinningColumns = [...newOrderedFields]; // Contains the fields not added to the orderedFields array yet\n\n      const remainingFields = [...columnsState.all]; // First, we check if the column was unpinned since the last processing.\n      // If yes and it still exists, we move it back to the same position it was before pinning\n\n      prevAllPinnedColumns.current.forEach(field => {\n        if (!allPinnedColumns.includes(field) && columnsState.lookup[field]) {\n          // Get the position before pinning\n          const index = orderedFieldsBeforePinningColumns.indexOf(field);\n          newOrderedFields[index] = field;\n          newOrderedFieldsBeforePinningColumns[index] = field; // This field was already consumed so we prevent from being added again\n\n          remainingFields.splice(remainingFields.indexOf(field), 1);\n        }\n      }); // For columns still pinned, we keep stored their original positions\n\n      allPinnedColumns.forEach(field => {\n        let index = orderedFieldsBeforePinningColumns.indexOf(field); // If index = -1, the pinned field didn't exist in the last processing, it's possibly being added now\n        // If index >= newOrderedFieldsBeforePinningColumns.length, then one or more columns were removed\n        // In both cases, use the position from the columns array\n        // TODO: detect removed columns and decrease the positions after it\n\n        if (index === -1 || index >= newOrderedFieldsBeforePinningColumns.length) {\n          index = columnsState.all.indexOf(field);\n        } // The fallback above may make the column to be inserted in a position already occupied\n        // In this case, put it in any empty slot available\n\n\n        if (newOrderedFieldsBeforePinningColumns[index] !== null) {\n          index = 0;\n\n          while (newOrderedFieldsBeforePinningColumns[index] !== null) {\n            index += 1;\n          }\n        }\n\n        newOrderedFields[index] = field;\n        newOrderedFieldsBeforePinningColumns[index] = field; // This field was already consumed so we prevent from being added again\n\n        remainingFields.splice(remainingFields.indexOf(field), 1);\n      }); // The fields remaining are those that're neither pinnned nor were unpinned\n      // For these, we spread them across both arrays making sure to not override existing values\n\n      let i = 0;\n      remainingFields.forEach(field => {\n        while (newOrderedFieldsBeforePinningColumns[i] !== null) {\n          i += 1;\n        }\n\n        newOrderedFieldsBeforePinningColumns[i] = field;\n        newOrderedFields[i] = field;\n      });\n      apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;\n    } else {\n      newOrderedFields = [...columnsState.all];\n      apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = [...columnsState.all];\n    }\n\n    prevAllPinnedColumns.current = allPinnedColumns;\n    const centerColumns = newOrderedFields.filter(field => {\n      return !leftPinnedColumns.includes(field) && !rightPinnedColumns.includes(field);\n    });\n    return _extends({}, columnsState, {\n      all: [...leftPinnedColumns, ...centerColumns, ...rightPinnedColumns]\n    });\n  }, [apiRef, disableColumnPinning, pinnedColumns]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateColumns', reorderPinnedColumns);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}