import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import { capitalize } from '@mui/material';
import { addPinnedRow, isDeepEqual } from '@mui/x-data-grid-pro/internals';
export var GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = 'auto-generated-group-footer-root';
export var getAggregationFooterRowIdFromGroupId = function getAggregationFooterRowIdFromGroupId(groupId) {
  if (groupId == null) {
    return GRID_AGGREGATION_ROOT_FOOTER_ROW_ID;
  }

  return "auto-generated-group-footer-".concat(groupId);
};
export var canColumnHaveAggregationFunction = function canColumnHaveAggregationFunction(_ref) {
  var column = _ref.column,
      aggregationFunctionName = _ref.aggregationFunctionName,
      aggregationFunction = _ref.aggregationFunction;

  if (!column || !column.aggregable) {
    return false;
  }

  if (!aggregationFunction) {
    return false;
  }

  if (column.availableAggregationFunctions != null) {
    return column.availableAggregationFunctions.includes(aggregationFunctionName);
  }

  if (!aggregationFunction.columnTypes) {
    return true;
  }

  return aggregationFunction.columnTypes.includes(column.type);
};
export var getAvailableAggregationFunctions = function getAvailableAggregationFunctions(_ref2) {
  var aggregationFunctions = _ref2.aggregationFunctions,
      column = _ref2.column;
  return Object.keys(aggregationFunctions).filter(function (aggregationFunctionName) {
    return canColumnHaveAggregationFunction({
      column: column,
      aggregationFunctionName: aggregationFunctionName,
      aggregationFunction: aggregationFunctions[aggregationFunctionName]
    });
  });
};
export var mergeStateWithAggregationModel = function mergeStateWithAggregationModel(aggregationModel) {
  return function (state) {
    return _extends({}, state, {
      aggregation: _extends({}, state.aggregation, {
        model: aggregationModel
      })
    });
  };
};
export var getAggregationRules = function getAggregationRules(_ref3) {
  var columnsLookup = _ref3.columnsLookup,
      aggregationModel = _ref3.aggregationModel,
      aggregationFunctions = _ref3.aggregationFunctions;
  var aggregationRules = {};
  Object.entries(aggregationModel).forEach(function (_ref4) {
    var _ref5 = _slicedToArray(_ref4, 2),
        field = _ref5[0],
        columnItem = _ref5[1];

    if (columnsLookup[field] && canColumnHaveAggregationFunction({
      column: columnsLookup[field],
      aggregationFunctionName: columnItem,
      aggregationFunction: aggregationFunctions[columnItem]
    })) {
      aggregationRules[field] = {
        aggregationFunctionName: columnItem,
        aggregationFunction: aggregationFunctions[columnItem]
      };
    }
  });
  return aggregationRules;
};
/**
 * Add a footer for each group that has at least one column with an aggregated value.
 */

export var addFooterRows = function addFooterRows(_ref6) {
  var groupingParams = _ref6.groupingParams,
      aggregationRules = _ref6.aggregationRules,
      getAggregationPosition = _ref6.getAggregationPosition,
      apiRef = _ref6.apiRef;

  if (Object.keys(aggregationRules).length === 0) {
    return groupingParams;
  }

  var ids = _toConsumableArray(groupingParams.ids);

  var idRowsLookup = _extends({}, groupingParams.idRowsLookup);

  var tree = _extends({}, groupingParams.tree);

  var addGroupFooter = function addGroupFooter(groupNode) {
    var _groupNode$id;

    var groupId = (_groupNode$id = groupNode == null ? void 0 : groupNode.id) != null ? _groupNode$id : null;

    if (getAggregationPosition(groupNode) !== 'footer') {
      return;
    }

    var footerId = getAggregationFooterRowIdFromGroupId(groupId);
    ids.push(footerId);
    idRowsLookup[footerId] = {};
    tree[footerId] = {
      id: footerId,
      isAutoGenerated: true,
      parent: groupId,
      depth: groupNode ? groupNode.depth + 1 : 0,
      groupingKey: null,
      groupingField: null,
      position: 'footer'
    };

    if (groupId != null) {
      tree[groupId] = _extends({}, tree[groupId], {
        footerId: footerId
      });
    }
  }; // If the tree is flat, we don't need to loop through the rows


  if (groupingParams.treeDepth > 1) {
    groupingParams.ids.forEach(function (parentId) {
      var parentNode = tree[parentId];

      if (parentNode.depth === groupingParams.treeDepth - 1) {
        return;
      }

      addGroupFooter(parentNode);
    });
  }

  var newGroupingParams = _extends({}, groupingParams, {
    tree: tree,
    idRowsLookup: idRowsLookup,
    ids: ids
  });

  if (getAggregationPosition(null) === 'footer') {
    newGroupingParams = addPinnedRow({
      groupingParams: newGroupingParams,
      rowModel: {},
      rowId: getAggregationFooterRowIdFromGroupId(null),
      position: 'bottom',
      apiRef: apiRef
    });
  }

  return _extends({}, groupingParams, newGroupingParams);
};
/**
 * Compares two sets of aggregation rules to determine if they are equal or not.
 */

export var areAggregationRulesEqual = function areAggregationRulesEqual(previousValue, newValue) {
  var previousFields = Object.keys(previousValue != null ? previousValue : {});
  var newFields = Object.keys(newValue);

  if (!isDeepEqual(previousFields, newFields)) {
    return false;
  }

  return newFields.every(function (field) {
    var previousRule = previousValue == null ? void 0 : previousValue[field];
    var newRule = newValue[field];

    if ((previousRule == null ? void 0 : previousRule.aggregationFunction) !== (newRule == null ? void 0 : newRule.aggregationFunction)) {
      return false;
    }

    if ((previousRule == null ? void 0 : previousRule.aggregationFunctionName) !== (newRule == null ? void 0 : newRule.aggregationFunctionName)) {
      return false;
    }

    return true;
  });
};
export var getAggregationFunctionLabel = function getAggregationFunctionLabel(_ref7) {
  var apiRef = _ref7.apiRef,
      aggregationRule = _ref7.aggregationRule;

  if (aggregationRule.aggregationFunction.label != null) {
    return aggregationRule.aggregationFunction.label;
  }

  try {
    return apiRef.current.getLocaleText("aggregationFunctionLabel".concat(capitalize(aggregationRule.aggregationFunctionName)));
  } catch (e) {
    return aggregationRule.aggregationFunctionName;
  }
};