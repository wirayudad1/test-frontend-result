import _extends from "@babel/runtime/helpers/esm/extends";
import { capitalize } from '@mui/material';
import { addPinnedRow, isDeepEqual } from '@mui/x-data-grid-pro/internals';
export const GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = 'auto-generated-group-footer-root';
export const getAggregationFooterRowIdFromGroupId = groupId => {
  if (groupId == null) {
    return GRID_AGGREGATION_ROOT_FOOTER_ROW_ID;
  }

  return `auto-generated-group-footer-${groupId}`;
};
export const canColumnHaveAggregationFunction = ({
  column,
  aggregationFunctionName,
  aggregationFunction
}) => {
  if (!column || !column.aggregable) {
    return false;
  }

  if (!aggregationFunction) {
    return false;
  }

  if (column.availableAggregationFunctions != null) {
    return column.availableAggregationFunctions.includes(aggregationFunctionName);
  }

  if (!aggregationFunction.columnTypes) {
    return true;
  }

  return aggregationFunction.columnTypes.includes(column.type);
};
export const getAvailableAggregationFunctions = ({
  aggregationFunctions,
  column
}) => Object.keys(aggregationFunctions).filter(aggregationFunctionName => canColumnHaveAggregationFunction({
  column,
  aggregationFunctionName,
  aggregationFunction: aggregationFunctions[aggregationFunctionName]
}));
export const mergeStateWithAggregationModel = aggregationModel => state => _extends({}, state, {
  aggregation: _extends({}, state.aggregation, {
    model: aggregationModel
  })
});
export const getAggregationRules = ({
  columnsLookup,
  aggregationModel,
  aggregationFunctions
}) => {
  const aggregationRules = {};
  Object.entries(aggregationModel).forEach(([field, columnItem]) => {
    if (columnsLookup[field] && canColumnHaveAggregationFunction({
      column: columnsLookup[field],
      aggregationFunctionName: columnItem,
      aggregationFunction: aggregationFunctions[columnItem]
    })) {
      aggregationRules[field] = {
        aggregationFunctionName: columnItem,
        aggregationFunction: aggregationFunctions[columnItem]
      };
    }
  });
  return aggregationRules;
};
/**
 * Add a footer for each group that has at least one column with an aggregated value.
 */

export const addFooterRows = ({
  groupingParams,
  aggregationRules,
  getAggregationPosition,
  apiRef
}) => {
  if (Object.keys(aggregationRules).length === 0) {
    return groupingParams;
  }

  const ids = [...groupingParams.ids];

  const idRowsLookup = _extends({}, groupingParams.idRowsLookup);

  const tree = _extends({}, groupingParams.tree);

  const addGroupFooter = groupNode => {
    const groupId = groupNode?.id ?? null;

    if (getAggregationPosition(groupNode) !== 'footer') {
      return;
    }

    const footerId = getAggregationFooterRowIdFromGroupId(groupId);
    ids.push(footerId);
    idRowsLookup[footerId] = {};
    tree[footerId] = {
      id: footerId,
      isAutoGenerated: true,
      parent: groupId,
      depth: groupNode ? groupNode.depth + 1 : 0,
      groupingKey: null,
      groupingField: null,
      position: 'footer'
    };

    if (groupId != null) {
      tree[groupId] = _extends({}, tree[groupId], {
        footerId
      });
    }
  }; // If the tree is flat, we don't need to loop through the rows


  if (groupingParams.treeDepth > 1) {
    groupingParams.ids.forEach(parentId => {
      const parentNode = tree[parentId];

      if (parentNode.depth === groupingParams.treeDepth - 1) {
        return;
      }

      addGroupFooter(parentNode);
    });
  }

  let newGroupingParams = _extends({}, groupingParams, {
    tree,
    idRowsLookup,
    ids
  });

  if (getAggregationPosition(null) === 'footer') {
    newGroupingParams = addPinnedRow({
      groupingParams: newGroupingParams,
      rowModel: {},
      rowId: getAggregationFooterRowIdFromGroupId(null),
      position: 'bottom',
      apiRef
    });
  }

  return _extends({}, groupingParams, newGroupingParams);
};
/**
 * Compares two sets of aggregation rules to determine if they are equal or not.
 */

export const areAggregationRulesEqual = (previousValue, newValue) => {
  const previousFields = Object.keys(previousValue ?? {});
  const newFields = Object.keys(newValue);

  if (!isDeepEqual(previousFields, newFields)) {
    return false;
  }

  return newFields.every(field => {
    const previousRule = previousValue?.[field];
    const newRule = newValue[field];

    if (previousRule?.aggregationFunction !== newRule?.aggregationFunction) {
      return false;
    }

    if (previousRule?.aggregationFunctionName !== newRule?.aggregationFunctionName) {
      return false;
    }

    return true;
  });
};
export const getAggregationFunctionLabel = ({
  apiRef,
  aggregationRule
}) => {
  if (aggregationRule.aggregationFunction.label != null) {
    return aggregationRule.aggregationFunction.label;
  }

  try {
    return apiRef.current.getLocaleText(`aggregationFunctionLabel${capitalize(aggregationRule.aggregationFunctionName)}`);
  } catch (e) {
    return aggregationRule.aggregationFunctionName;
  }
};