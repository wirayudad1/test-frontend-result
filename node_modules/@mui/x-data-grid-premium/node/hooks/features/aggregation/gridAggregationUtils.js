"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeStateWithAggregationModel = exports.getAvailableAggregationFunctions = exports.getAggregationRules = exports.getAggregationFunctionLabel = exports.getAggregationFooterRowIdFromGroupId = exports.canColumnHaveAggregationFunction = exports.areAggregationRulesEqual = exports.addFooterRows = exports.GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _material = require("@mui/material");

var _internals = require("@mui/x-data-grid-pro/internals");

const GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = 'auto-generated-group-footer-root';
exports.GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = GRID_AGGREGATION_ROOT_FOOTER_ROW_ID;

const getAggregationFooterRowIdFromGroupId = groupId => {
  if (groupId == null) {
    return GRID_AGGREGATION_ROOT_FOOTER_ROW_ID;
  }

  return `auto-generated-group-footer-${groupId}`;
};

exports.getAggregationFooterRowIdFromGroupId = getAggregationFooterRowIdFromGroupId;

const canColumnHaveAggregationFunction = ({
  column,
  aggregationFunctionName,
  aggregationFunction
}) => {
  if (!column || !column.aggregable) {
    return false;
  }

  if (!aggregationFunction) {
    return false;
  }

  if (column.availableAggregationFunctions != null) {
    return column.availableAggregationFunctions.includes(aggregationFunctionName);
  }

  if (!aggregationFunction.columnTypes) {
    return true;
  }

  return aggregationFunction.columnTypes.includes(column.type);
};

exports.canColumnHaveAggregationFunction = canColumnHaveAggregationFunction;

const getAvailableAggregationFunctions = ({
  aggregationFunctions,
  column
}) => Object.keys(aggregationFunctions).filter(aggregationFunctionName => canColumnHaveAggregationFunction({
  column,
  aggregationFunctionName,
  aggregationFunction: aggregationFunctions[aggregationFunctionName]
}));

exports.getAvailableAggregationFunctions = getAvailableAggregationFunctions;

const mergeStateWithAggregationModel = aggregationModel => state => (0, _extends2.default)({}, state, {
  aggregation: (0, _extends2.default)({}, state.aggregation, {
    model: aggregationModel
  })
});

exports.mergeStateWithAggregationModel = mergeStateWithAggregationModel;

const getAggregationRules = ({
  columnsLookup,
  aggregationModel,
  aggregationFunctions
}) => {
  const aggregationRules = {};
  Object.entries(aggregationModel).forEach(([field, columnItem]) => {
    if (columnsLookup[field] && canColumnHaveAggregationFunction({
      column: columnsLookup[field],
      aggregationFunctionName: columnItem,
      aggregationFunction: aggregationFunctions[columnItem]
    })) {
      aggregationRules[field] = {
        aggregationFunctionName: columnItem,
        aggregationFunction: aggregationFunctions[columnItem]
      };
    }
  });
  return aggregationRules;
};
/**
 * Add a footer for each group that has at least one column with an aggregated value.
 */


exports.getAggregationRules = getAggregationRules;

const addFooterRows = ({
  groupingParams,
  aggregationRules,
  getAggregationPosition,
  apiRef
}) => {
  if (Object.keys(aggregationRules).length === 0) {
    return groupingParams;
  }

  const ids = [...groupingParams.ids];
  const idRowsLookup = (0, _extends2.default)({}, groupingParams.idRowsLookup);
  const tree = (0, _extends2.default)({}, groupingParams.tree);

  const addGroupFooter = groupNode => {
    var _groupNode$id;

    const groupId = (_groupNode$id = groupNode == null ? void 0 : groupNode.id) != null ? _groupNode$id : null;

    if (getAggregationPosition(groupNode) !== 'footer') {
      return;
    }

    const footerId = getAggregationFooterRowIdFromGroupId(groupId);
    ids.push(footerId);
    idRowsLookup[footerId] = {};
    tree[footerId] = {
      id: footerId,
      isAutoGenerated: true,
      parent: groupId,
      depth: groupNode ? groupNode.depth + 1 : 0,
      groupingKey: null,
      groupingField: null,
      position: 'footer'
    };

    if (groupId != null) {
      tree[groupId] = (0, _extends2.default)({}, tree[groupId], {
        footerId
      });
    }
  }; // If the tree is flat, we don't need to loop through the rows


  if (groupingParams.treeDepth > 1) {
    groupingParams.ids.forEach(parentId => {
      const parentNode = tree[parentId];

      if (parentNode.depth === groupingParams.treeDepth - 1) {
        return;
      }

      addGroupFooter(parentNode);
    });
  }

  let newGroupingParams = (0, _extends2.default)({}, groupingParams, {
    tree,
    idRowsLookup,
    ids
  });

  if (getAggregationPosition(null) === 'footer') {
    newGroupingParams = (0, _internals.addPinnedRow)({
      groupingParams: newGroupingParams,
      rowModel: {},
      rowId: getAggregationFooterRowIdFromGroupId(null),
      position: 'bottom',
      apiRef
    });
  }

  return (0, _extends2.default)({}, groupingParams, newGroupingParams);
};
/**
 * Compares two sets of aggregation rules to determine if they are equal or not.
 */


exports.addFooterRows = addFooterRows;

const areAggregationRulesEqual = (previousValue, newValue) => {
  const previousFields = Object.keys(previousValue != null ? previousValue : {});
  const newFields = Object.keys(newValue);

  if (!(0, _internals.isDeepEqual)(previousFields, newFields)) {
    return false;
  }

  return newFields.every(field => {
    const previousRule = previousValue == null ? void 0 : previousValue[field];
    const newRule = newValue[field];

    if ((previousRule == null ? void 0 : previousRule.aggregationFunction) !== (newRule == null ? void 0 : newRule.aggregationFunction)) {
      return false;
    }

    if ((previousRule == null ? void 0 : previousRule.aggregationFunctionName) !== (newRule == null ? void 0 : newRule.aggregationFunctionName)) {
      return false;
    }

    return true;
  });
};

exports.areAggregationRulesEqual = areAggregationRulesEqual;

const getAggregationFunctionLabel = ({
  apiRef,
  aggregationRule
}) => {
  if (aggregationRule.aggregationFunction.label != null) {
    return aggregationRule.aggregationFunction.label;
  }

  try {
    return apiRef.current.getLocaleText(`aggregationFunctionLabel${(0, _material.capitalize)(aggregationRule.aggregationFunctionName)}`);
  } catch (e) {
    return aggregationRule.aggregationFunctionName;
  }
};

exports.getAggregationFunctionLabel = getAggregationFunctionLabel;